<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Computes z^n for integer n using exponentiation by squaring.          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/07/04                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  stdio provides the &quot;printf&quot; function, used for printing text.             */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="cm">/*  Complex numbers provided here.                                            */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;complex&gt;</span>

<span class="cm">/*  Print a complex number in standard form, x + y*i.                         */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_complex</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  We can use printf with the correct format specifiers to do the job.   */</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.16E + %.16E*i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">real</span><span class="p">(),</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">imag</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*  Computes powers of a given complex number by repeatedly squaring.         */</span>
<span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">exp_by_squaring</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  We start off with out = z, and then apply out = out^2 repeatedly.     */</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The scale factor is used to handle odd powers. That is, if we have    *</span>
<span class="cm">     *  z^(2n+1), we can write this as z^(2n) * z = (z^2)^n * z. The scale    *</span>
<span class="cm">     *  factor will pick up the solo &quot;z&quot; term, and the squaring part handles  *</span>
<span class="cm">     *  (z^2)^n. Create a variable for this and initialize it to 1.           */</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Special case. If n = 0, then z^0 = 1, by definition. Return 1.        */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  For negative powers use z^n = (1 / z)^(-n) to reduce n to positive.   */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="w">        </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Start the process. Compute z^n by removing all of the even factors    *</span>
<span class="cm">     *  for n, iteratively updating the output along the way.                 */</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  If n is odd, n = 2*k+1, and if w = output, then:                  *</span>
<span class="cm">         *                                                                    *</span>
<span class="cm">         *       n    2k + 1                                                  *</span>
<span class="cm">         *      w  = w                                                        *</span>
<span class="cm">         *                                                                    *</span>
<span class="cm">         *            -  2 -  n                                               *</span>
<span class="cm">         *         = | w    |   * w                                           *</span>
<span class="cm">         *            -    -                                                  *</span>
<span class="cm">         *                                                                    *</span>
<span class="cm">         *  Multiply &quot;scale&quot; by &quot;output&quot; to handle the &quot;* w&quot; on the right     *</span>
<span class="cm">         *  side of the expression. We can continue squaring, replacing       *</span>
<span class="cm">         *  output with output^2, to handle portion of this expression that   *</span>
<span class="cm">         *  is inside of the parentheses.                                     */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">scale</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="w">            </span><span class="o">--</span><span class="n">n</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  n is now even. Square the output and divide n by two.             */</span>
<span class="w">        </span><span class="n">output</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="w">        </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  n is now 1. The final output is output * scale. Compute this.         */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  Let&#39;s extend the complex&lt;double&gt; class by providing the &quot;^&quot; operator.     */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Complex</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>

<span class="w">        </span><span class="cm">/*  Constructor from real and imaginary parts, z = x + iy.            */</span>
<span class="w">        </span><span class="n">Complex</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">imag</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">imag</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  Nothing to do, simply inherit the std::complex constructor.   */</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Constructor from a complex number, z = w.                         */</span>
<span class="w">        </span><span class="n">Complex</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  Similarly, we do not need to add more functionality.          */</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Provide the &quot;^&quot; operator for complex numbers. We can then write   *</span>
<span class="cm">         *  something like w = z^n, instead of w = exp_by_squaring(z, n).     */</span>
<span class="w">        </span><span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">Complex</span><span class="p">(</span><span class="n">exp_by_squaring</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Provide the print function as a method for the class.             */</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">print_complex</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*  Test our routines by computing 1 / (1 + i)^30.                            */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-30</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="o">^</span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="n">w</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
