<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">################################################################################</span>
<span class="sd">#                                   LICENSE                                    #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="sd">#   redistribute it and/or modify it under the terms of the GNU General        #</span>
<span class="sd">#   Public License as published by the Free Software Foundation, either        #</span>
<span class="sd">#   version 3 of the License, or (at your option) any later version.           #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is distributed in the hope that      #</span>
<span class="sd">#   it will be useful but WITHOUT ANY WARRANTY; without even the implied       #</span>
<span class="sd">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.           #</span>
<span class="sd">#   See the GNU General Public License for more details.                       #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   You should have received a copy of the GNU General Public License          #</span>
<span class="sd">#   along with mitx_mathematics_programming_examples. If not, see              #</span>
<span class="sd">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Purpose:                                                                   #</span>
<span class="sd">#       Implements complex numbers using a Python class.                       #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Author: Ryan Maguire                                                       #</span>
<span class="sd">#   Date:   2024/11/05                                                         #</span>
<span class="sd">################################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># The modulus and principal argument of a complex number are computed using</span>
<span class="c1"># the square root function and the arctan function. These are found here.</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class:</span>
<span class="sd">            Complex</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Python class for working with complex numbers.</span>
<span class="sd">            This contains methods (functions) for working with</span>
<span class="sd">            common routines found in complex analysis, and</span>
<span class="sd">            implements the basics of complex arithmetic.</span>
<span class="sd">        Attributes:</span>
<span class="sd">            real (float):</span>
<span class="sd">                The real part of the complex number.</span>
<span class="sd">            imag (float):</span>
<span class="sd">                The imaginary part of the complex number.</span>
<span class="sd">        Operators:</span>
<span class="sd">            + (complex addition)</span>
<span class="sd">            += (in-place complex addition)</span>
<span class="sd">            - (complex subtraction)</span>
<span class="sd">            -= (in-place complex subtraction)</span>
<span class="sd">            * (complex multiplication)</span>
<span class="sd">            *= (in-place complex multiplication)</span>
<span class="sd">            / (complex division)</span>
<span class="sd">            /= (in-place complex division)</span>
<span class="sd">            - (unary operator, complex negation)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                __init__</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Creates an instance of the Complex class.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                real (float):</span>
<span class="sd">                    The real part of the complex number.</span>
<span class="sd">                imag (float):</span>
<span class="sd">                    The imaginary part of the complex number.</span>
<span class="sd">            Output:</span>
<span class="sd">                z (Complex):</span>
<span class="sd">                    The complex number real + i*imag</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Both inputs should be &quot;floats&quot;, which are real numbers in a computer.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">imag</span><span class="p">)</span>

        <span class="c1"># If we can&#39;t convert the inputs into floats, the user gave invalid</span>
        <span class="c1"># inputs. Treat this as an error.</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;A complex number is created from two real numbers.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="c1"># + operator for complex addition.</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Addition (+).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex addition.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being added to self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                sum (Complex):</span>
<span class="sd">                    The complex sum of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Add the complex numbers component-wise. If self and other</span>
<span class="sd">                are represented as z = a + ib and w = c + id,</span>
<span class="sd">                respectively, the sum is then:</span>

<span class="sd">                    z + w = (a + ib) + (c + id)</span>
<span class="sd">                          = (a + c) + i(b + d)</span>

<span class="sd">                That is, complex addition is done component-wise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We can only add complex numbers and real numbers together. Check if</span>
        <span class="c1"># the input is either of these.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot add.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here, the input was a real number. We can add.</span>
            <span class="n">real_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">other_real</span>
            <span class="n">imag_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_sum</span><span class="p">,</span> <span class="n">imag_sum</span><span class="p">)</span>

        <span class="c1"># If we get here, the input is a complex number. Add the components.</span>
        <span class="n">real_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_sum</span><span class="p">,</span> <span class="n">imag_sum</span><span class="p">)</span>

    <span class="c1"># += operator for complex addition.</span>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Addition (+=).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex addition in-place.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being added to self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                self</span>
<span class="sd">            Method:</span>
<span class="sd">                Perform complex addition component-wise and store</span>
<span class="sd">                the result in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Similar error check to the one found in __add__.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot add.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># If we get here, the input is a complex number. Add the components.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># - operator for complex subtraction.</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Subtraction (-).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex subtraction.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being subtracted from self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                diff (Complex):</span>
<span class="sd">                    The complex difference of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Subtract the complex numbers component-wise. If self</span>
<span class="sd">                and other are represented as z = a + ib and w = c + id,</span>
<span class="sd">                respectively, the difference is then:</span>

<span class="sd">                    z - w = (a + ib) - (c + id)</span>
<span class="sd">                          = (a - c) + i(b - d)</span>

<span class="sd">                That is, complex subtraction is done component-wise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We can only subtract complex numbers and real numbers. Check if</span>
        <span class="c1"># the input is either of these.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot subtract.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here, the input was a real number. We can subtract.</span>
            <span class="n">real_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">other_real</span>
            <span class="n">imag_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_diff</span><span class="p">,</span> <span class="n">imag_diff</span><span class="p">)</span>

        <span class="c1"># If we get here, the input is a complex number. Subtract components.</span>
        <span class="n">real_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_diff</span><span class="p">,</span> <span class="n">imag_diff</span><span class="p">)</span>

    <span class="c1"># -= operator for complex subtraction.</span>
    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Subtraction (-=).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex subtraction in-place.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being subtracted from self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                self</span>
<span class="sd">            Method:</span>
<span class="sd">                Perform complex subtraction component-wise and store</span>
<span class="sd">                the result in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Subtraction can be done with real or complex numbers.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot subtract.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># If we get here, the input is a complex number. Subtract components.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">-=</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># * operator for complex multiplication.</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Multiplication (*).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex multiplication.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    A complex number.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                prod (Complex):</span>
<span class="sd">                    The product of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Complex multiplication is computed using i^2 = -1.</span>
<span class="sd">                That is, if z = a + ib, and w = c + id, then:</span>

<span class="sd">                    z*w = (a + ib) * (c + id)</span>
<span class="sd">                        = ac + ibc + iad + i^2bd</span>
<span class="sd">                        = (ac - bd) + i(ad + bc)</span>

<span class="sd">                If other is purely real, this is just scalar multiplication.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The input must be a real or complex number.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot multiply.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here the input was a real number. Multiply components.</span>
            <span class="n">prod_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other_real</span>
            <span class="n">prod_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other_real</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

        <span class="c1"># If we get here, the input was complex.</span>
        <span class="n">prod_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">prod_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

    <span class="c1"># * operator for complex multiplication on the right.</span>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Multiplication (*).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex multiplication (on the right).</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    A complex number.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                prod (Complex):</span>
<span class="sd">                    The product of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Complex multiplication is commutative, so this operator</span>
<span class="sd">                does the same thing as multiplication on the left.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The input must be a real or complex number.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot multiply.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here the input was a real number. Multiply components.</span>
            <span class="n">prod_real</span> <span class="o">=</span> <span class="n">other_real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>
            <span class="n">prod_imag</span> <span class="o">=</span> <span class="n">other_real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

        <span class="c1"># If we get here, the input was complex.</span>
        <span class="n">prod_real</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">prod_imag</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

    <span class="c1"># *= operator for complex multiplication.</span>
    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Multiplication (*=).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex multiplication in-place.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    A complex number.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Performing complex multiplication naively in-place will</span>
<span class="sd">                overwrite the real part first, meaning the imaginary part</span>
<span class="sd">                will get the wrong input. We correct this by saving the</span>
<span class="sd">                real part as a new variable, and performing complex</span>
<span class="sd">                multiplication with this.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The input must be a real or complex number.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot multiply.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here the input was a real number. Multiply components.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*=</span> <span class="n">other_real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*=</span> <span class="n">other_real</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># If we get here, the input was complex. Avoid overwriting data,</span>
        <span class="c1"># save the real part of self before computing.</span>
        <span class="n">self_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># We can now perform the product.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">self_real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># Negation operator.</span>
    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Negation (-):</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Negates a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                neg_self (Complex):</span>
<span class="sd">                    The negation of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Negate each component and return.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Negate all components and return.</span>
        <span class="n">real_val</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_val</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_val</span><span class="p">,</span> <span class="n">imag_val</span><span class="p">)</span>

    <span class="c1"># Complex conjugation.</span>
    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                conj</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Computes the complex conjugate of a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                conj_self (Complex):</span>
<span class="sd">                    The complex conjugate of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Negate the imaginary part and return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="c1"># Computes the complex modulus, or magnitude, of a complex number.</span>
    <span class="k">def</span> <span class="nf">modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                modulus</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Computes the complex modulus of a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                abs_z (Complex):</span>
<span class="sd">                    The magnitude of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Use the Pythagorean formula.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Pythagorean formula: Square root of the sum of the squares.</span>
        <span class="n">real_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">real_squared</span> <span class="o">+</span> <span class="n">imag_squared</span><span class="p">)</span>

    <span class="c1"># Computes the principal argument of a complex number.</span>
    <span class="k">def</span> <span class="nf">arg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                arg</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Computes the principal argument of a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                arg_z (Complex):</span>
<span class="sd">                    The principal argument of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Use the atan2 function from the math module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="c1"># Used for copying an instance of a complex number into a new variable.</span>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                copy</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Copies the data of self to a new variable.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                self_copy (Complex):</span>
<span class="sd">                    A copy of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="c1"># Converts a complex number into a string.</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                __str__</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Converts a complex number into a string. Used for printing.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                self_string (str):</span>
<span class="sd">                    String representation of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the imaginary part is negative, write real - |imag| i, instead</span>
        <span class="c1"># of writing real + -imag i.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="si">}</span><span class="s1"> i&#39;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="si">}</span><span class="s1"> + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="si">}</span><span class="s1"> i&#39;</span>

<span class="c1"># Let&#39;s test our routines.</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="c1"># Two test complex numbers to play with.</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Test out negation.</span>
    <span class="n">neg_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span>

    <span class="c1"># Test out complex arithmetic.</span>
    <span class="n">summ</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">w</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">w</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">w</span>

    <span class="c1"># And try scalar multiplication.</span>
    <span class="n">right_scale</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="mf">4.0</span>
    <span class="n">left_scale</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">z</span>

    <span class="c1"># Test basic complex functions.</span>
    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">modulus</span><span class="p">()</span>
    <span class="n">argument</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">arg</span><span class="p">()</span>

    <span class="c1"># Lastly, try out in-place arithmetic.</span>
    <span class="n">new_sum</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_diff</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_prod</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">new_sum</span> <span class="o">+=</span> <span class="n">w</span>
    <span class="n">new_diff</span> <span class="o">-=</span> <span class="n">w</span>
    <span class="n">new_prod</span> <span class="o">*=</span> <span class="n">w</span>

    <span class="c1"># Print all of the results to the screen.</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z = </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;w = </span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;-z = </span><span class="si">{</span><span class="n">neg_z</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z + w = </span><span class="si">{</span><span class="n">summ</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z - w = </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z * w = </span><span class="si">{</span><span class="n">prod</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;4 * z = </span><span class="si">{</span><span class="n">left_scale</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z * 4 = </span><span class="si">{</span><span class="n">right_scale</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;|z| = </span><span class="si">{</span><span class="n">magnitude</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arg(z) = </span><span class="si">{</span><span class="n">argument</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z += w -&gt; </span><span class="si">{</span><span class="n">new_sum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z -= w -&gt; </span><span class="si">{</span><span class="n">new_diff</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z *= w -&gt; </span><span class="si">{</span><span class="n">new_prod</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
