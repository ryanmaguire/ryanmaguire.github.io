<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ryan Maguire | Mathematics, Physics, and Programming</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Ryan Maguire" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Mathematics, Physics, and Programming" />
<meta property="og:description" content="Mathematics, Physics, and Programming" />
<link rel="canonical" href="https://github.com/ryanmaguire/programming/complex_variables/complex_numbers/basic_syntax/" />
<meta property="og:url" content="https://github.com/ryanmaguire/programming/complex_variables/complex_numbers/basic_syntax/" />
<meta property="og:site_name" content="Ryan Maguire" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ryan Maguire" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Mathematics, Physics, and Programming","headline":"Ryan Maguire","url":"https://github.com/ryanmaguire/programming/complex_variables/complex_numbers/basic_syntax/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://github.com/ryanmaguire/feed.xml" title="Ryan Maguire" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Ryan Maguire</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/asymptote/">Asymptote</a><a class="page-link" href="/papers/">Papers</a><a class="page-link" href="/presentations/">Presentations</a><a class="page-link" href="/programming/">Programming</a><a class="page-link" href="/projects/">Projects</a><a class="page-link" href="/teaching/">Teaching</a><a class="page-link" href="/threejs/">Three.js</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <p><a href="../"><strong>Back</strong></a></p>

<h2 id="c">C<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Provides basic syntax for complex numbers using the C89 standard.     *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2024/11/04                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  As before, stdio.h provides the &quot;printf&quot; function.                        */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cm">/*  The standard library provides sqrt and atan2. sqrt computes the square    *</span>
<span class="cm"> *  root of a non-negative real number, and atan2 computes the angle the      *</span>
<span class="cm"> *  point (x, y) in the plane makes with the x axis.                          */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>

<span class="cm">/*  Mimicing other programming libraries, let&#39;s define a complex number as an *</span>
<span class="cm"> *  ordered pair of real numbers.                                             */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">real</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">imag</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">complex</span><span class="p">;</span>

<span class="cm">/*  UNIMPORTANT NOTE.                                                         *</span>
<span class="cm"> *      Every function to follow (except main) will have the word &quot;static&quot;    *</span>
<span class="cm"> *      before it. This simply means the function is only used in this file.  *</span>
<span class="cm"> *      Since this is a small demo, and not a programming library, every      *</span>
<span class="cm"> *      function is declared &quot;static.&quot; Doing this makes compilers happier.    *</span>
<span class="cm"> *      The student can simply ignore this keyword.                           */</span>

<span class="cm">/*  This function computes the real part of a complex number. It is           *</span>
<span class="cm"> *  equivalent to Re(z) in our notation.                                      */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">real_part</span><span class="p">(</span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  To access the elements in our &quot;struct&quot;, we use dot notation.          *</span>
<span class="cm">     *  z is a struct with variables &quot;real&quot; and &quot;imag&quot; stored inside.         *</span>
<span class="cm">     *  To access the &quot;real&quot; variable, we write z.real.                       *</span>
<span class="cm">     *  Return this to compute the real part of z.                            */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  Similarly, this function computes Im(z).                                  */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">imag_part</span><span class="p">(</span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  To access imag, write z.imag.                                         */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">imag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  This function computes the magnitude of z.                                */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">modulus</span><span class="p">(</span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  Use the Pythagorean formula to compute |z|.                           */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">real_squared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">real</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">imag_squared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">imag</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">imag</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Pythagoras: Square root of the sum of the squares.                    */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">real_squared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">imag_squared</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  Computes the principal argument of z.                                     */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">principal_argument</span><span class="p">(</span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  math.h provides atan2, which computes the angle the point (x, y)      *</span>
<span class="cm">     *  makes with the positive x axis. This is the unique number theta, with *</span>
<span class="cm">     *  -pi &lt; theta &lt;= pi, that contains (x, y) on the ray of angle theta. By *</span>
<span class="cm">     *  convention, atan2(0, 0) = 0.                                          *</span>
<span class="cm">     *                                                                        *</span>
<span class="cm">     *  NOTE:                                                                 *</span>
<span class="cm">     *      The syntax is theta = atan2(y, x). DO NOT WRITE atan2(x, y).      */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">atan2</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">real</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  Same routine as before, printing out some values using our new functions. */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  Lacking a compiler that implements complex numbers directly, we       *</span>
<span class="cm">     *  create complex numbers using &quot;struct&quot; syntax. This looks as follows.  */</span>
<span class="w">    </span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">};</span><span class="w"> </span><span class="cm">/* This is z = 1 + i. */</span>

<span class="w">    </span><span class="cm">/*  Get the real and imaginary parts of z.                                */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">real_part</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">imag_part</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  And get the polar form of z.                                          */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modulus</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">theta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">principal_argument</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Print everything to the screen, just as before.                       */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;z = %f + %f i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;|z| = |%f + %f i| = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Arg(z) = Arg(%f + %f i) = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">theta</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h2 id="python">Python<br /></h2>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">################################################################################</span>
<span class="sd">#                                   LICENSE                                    #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="sd">#   redistribute it and/or modify it under the terms of the GNU General        #</span>
<span class="sd">#   Public License as published by the Free Software Foundation, either        #</span>
<span class="sd">#   version 3 of the License, or (at your option) any later version.           #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is distributed in the hope that      #</span>
<span class="sd">#   it will be useful but WITHOUT ANY WARRANTY; without even the implied       #</span>
<span class="sd">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.           #</span>
<span class="sd">#   See the GNU General Public License for more details.                       #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   You should have received a copy of the GNU General Public License          #</span>
<span class="sd">#   along with mitx_mathematics_programming_examples. If not, see              #</span>
<span class="sd">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Purpose:                                                                   #</span>
<span class="sd">#       Implements complex numbers using a Python class.                       #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Author: Ryan Maguire                                                       #</span>
<span class="sd">#   Date:   2024/11/05                                                         #</span>
<span class="sd">################################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># The modulus and principal argument of a complex number are computed using</span>
<span class="c1"># the square root function and the arctan function. These are found here.</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class:</span>
<span class="sd">            Complex</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Python class for working with complex numbers.</span>
<span class="sd">            This contains methods (functions) for working with</span>
<span class="sd">            common routines found in complex analysis, and</span>
<span class="sd">            implements the basics of complex arithmetic.</span>
<span class="sd">        Attributes:</span>
<span class="sd">            real (float):</span>
<span class="sd">                The real part of the complex number.</span>
<span class="sd">            imag (float):</span>
<span class="sd">                The imaginary part of the complex number.</span>
<span class="sd">        Operators:</span>
<span class="sd">            + (complex addition)</span>
<span class="sd">            += (in-place complex addition)</span>
<span class="sd">            - (complex subtraction)</span>
<span class="sd">            -= (in-place complex subtraction)</span>
<span class="sd">            * (complex multiplication)</span>
<span class="sd">            *= (in-place complex multiplication)</span>
<span class="sd">            / (complex division)</span>
<span class="sd">            /= (in-place complex division)</span>
<span class="sd">            - (unary operator, complex negation)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                __init__</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Creates an instance of the Complex class.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                real (float):</span>
<span class="sd">                    The real part of the complex number.</span>
<span class="sd">                imag (float):</span>
<span class="sd">                    The imaginary part of the complex number.</span>
<span class="sd">            Output:</span>
<span class="sd">                z (Complex):</span>
<span class="sd">                    The complex number real + i*imag</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Both inputs should be &quot;floats&quot;, which are real numbers in a computer.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">imag</span><span class="p">)</span>

        <span class="c1"># If we can&#39;t convert the inputs into floats, the user gave invalid</span>
        <span class="c1"># inputs. Treat this as an error.</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;A complex number is created from two real numbers.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="c1"># + operator for complex addition.</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Addition (+).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex addition.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being added to self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                sum (Complex):</span>
<span class="sd">                    The complex sum of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Add the complex numbers component-wise. If self and other</span>
<span class="sd">                are represented as z = a + ib and w = c + id,</span>
<span class="sd">                respectively, the sum is then:</span>

<span class="sd">                    z + w = (a + ib) + (c + id)</span>
<span class="sd">                          = (a + c) + i(b + d)</span>

<span class="sd">                That is, complex addition is done component-wise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We can only add complex numbers and real numbers together. Check if</span>
        <span class="c1"># the input is either of these.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot add.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here, the input was a real number. We can add.</span>
            <span class="n">real_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">other_real</span>
            <span class="n">imag_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_sum</span><span class="p">,</span> <span class="n">imag_sum</span><span class="p">)</span>

        <span class="c1"># If we get here, the input is a complex number. Add the components.</span>
        <span class="n">real_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_sum</span><span class="p">,</span> <span class="n">imag_sum</span><span class="p">)</span>

    <span class="c1"># += operator for complex addition.</span>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Addition (+=).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex addition in-place.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being added to self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                self</span>
<span class="sd">            Method:</span>
<span class="sd">                Perform complex addition component-wise and store</span>
<span class="sd">                the result in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Similar error check to the one found in __add__.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot add.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># If we get here, the input is a complex number. Add the components.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># - operator for complex subtraction.</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Subtraction (-).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex subtraction.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being subtracted from self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                diff (Complex):</span>
<span class="sd">                    The complex difference of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Subtract the complex numbers component-wise. If self</span>
<span class="sd">                and other are represented as z = a + ib and w = c + id,</span>
<span class="sd">                respectively, the difference is then:</span>

<span class="sd">                    z - w = (a + ib) - (c + id)</span>
<span class="sd">                          = (a - c) + i(b - d)</span>

<span class="sd">                That is, complex subtraction is done component-wise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We can only subtract complex numbers and real numbers. Check if</span>
        <span class="c1"># the input is either of these.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot subtract.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here, the input was a real number. We can subtract.</span>
            <span class="n">real_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">other_real</span>
            <span class="n">imag_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_diff</span><span class="p">,</span> <span class="n">imag_diff</span><span class="p">)</span>

        <span class="c1"># If we get here, the input is a complex number. Subtract components.</span>
        <span class="n">real_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_diff</span><span class="p">,</span> <span class="n">imag_diff</span><span class="p">)</span>

    <span class="c1"># -= operator for complex subtraction.</span>
    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Subtraction (-=).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex subtraction in-place.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being subtracted from self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                self</span>
<span class="sd">            Method:</span>
<span class="sd">                Perform complex subtraction component-wise and store</span>
<span class="sd">                the result in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Subtraction can be done with real or complex numbers.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot subtract.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># If we get here, the input is a complex number. Subtract components.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">-=</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># * operator for complex multiplication.</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Multiplication (*).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex multiplication.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    A complex number.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                prod (Complex):</span>
<span class="sd">                    The product of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Complex multiplication is computed using i^2 = -1.</span>
<span class="sd">                That is, if z = a + ib, and w = c + id, then:</span>

<span class="sd">                    z*w = (a + ib) * (c + id)</span>
<span class="sd">                        = ac + ibc + iad + i^2bd</span>
<span class="sd">                        = (ac - bd) + i(ad + bc)</span>

<span class="sd">                If other is purely real, this is just scalar multiplication.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The input must be a real or complex number.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot multiply.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here the input was a real number. Multiply components.</span>
            <span class="n">prod_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other_real</span>
            <span class="n">prod_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other_real</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

        <span class="c1"># If we get here, the input was complex.</span>
        <span class="n">prod_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">prod_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

    <span class="c1"># * operator for complex multiplication on the right.</span>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Multiplication (*).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex multiplication (on the right).</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    A complex number.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                prod (Complex):</span>
<span class="sd">                    The product of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Complex multiplication is commutative, so this operator</span>
<span class="sd">                does the same thing as multiplication on the left.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The input must be a real or complex number.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot multiply.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here the input was a real number. Multiply components.</span>
            <span class="n">prod_real</span> <span class="o">=</span> <span class="n">other_real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>
            <span class="n">prod_imag</span> <span class="o">=</span> <span class="n">other_real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

        <span class="c1"># If we get here, the input was complex.</span>
        <span class="n">prod_real</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">prod_imag</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

    <span class="c1"># *= operator for complex multiplication.</span>
    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Multiplication (*=).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex multiplication in-place.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    A complex number.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Performing complex multiplication naively in-place will</span>
<span class="sd">                overwrite the real part first, meaning the imaginary part</span>
<span class="sd">                will get the wrong input. We correct this by saving the</span>
<span class="sd">                real part as a new variable, and performing complex</span>
<span class="sd">                multiplication with this.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The input must be a real or complex number.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot multiply.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here the input was a real number. Multiply components.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*=</span> <span class="n">other_real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*=</span> <span class="n">other_real</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># If we get here, the input was complex. Avoid overwriting data,</span>
        <span class="c1"># save the real part of self before computing.</span>
        <span class="n">self_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># We can now perform the product.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">self_real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># Negation operator.</span>
    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Negation (-):</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Negates a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                neg_self (Complex):</span>
<span class="sd">                    The negation of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Negate each component and return.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Negate all components and return.</span>
        <span class="n">real_val</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_val</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_val</span><span class="p">,</span> <span class="n">imag_val</span><span class="p">)</span>

    <span class="c1"># Complex conjugation.</span>
    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                conj</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Computes the complex conjugate of a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                conj_self (Complex):</span>
<span class="sd">                    The complex conjugate of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Negate the imaginary part and return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="c1"># Computes the complex modulus, or magnitude, of a complex number.</span>
    <span class="k">def</span> <span class="nf">modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                modulus</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Computes the complex modulus of a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                abs_z (Complex):</span>
<span class="sd">                    The magnitude of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Use the Pythagorean formula.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Pythagorean formula: Square root of the sum of the squares.</span>
        <span class="n">real_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">real_squared</span> <span class="o">+</span> <span class="n">imag_squared</span><span class="p">)</span>

    <span class="c1"># Computes the principal argument of a complex number.</span>
    <span class="k">def</span> <span class="nf">arg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                arg</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Computes the principal argument of a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                arg_z (Complex):</span>
<span class="sd">                    The principal argument of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Use the atan2 function from the math module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="c1"># Used for copying an instance of a complex number into a new variable.</span>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                copy</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Copies the data of self to a new variable.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                self_copy (Complex):</span>
<span class="sd">                    A copy of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="c1"># Converts a complex number into a string.</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                __str__</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Converts a complex number into a string. Used for printing.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                self_string (str):</span>
<span class="sd">                    String representation of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the imaginary part is negative, write real - |imag| i, instead</span>
        <span class="c1"># of writing real + -imag i.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="si">}</span><span class="s1"> i&#39;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="si">}</span><span class="s1"> + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="si">}</span><span class="s1"> i&#39;</span>

<span class="c1"># Let&#39;s test our routines.</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="c1"># Two test complex numbers to play with.</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Test out negation.</span>
    <span class="n">neg_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span>

    <span class="c1"># Test out complex arithmetic.</span>
    <span class="n">summ</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">w</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">w</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">w</span>

    <span class="c1"># And try scalar multiplication.</span>
    <span class="n">right_scale</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="mf">4.0</span>
    <span class="n">left_scale</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">z</span>

    <span class="c1"># Test basic complex functions.</span>
    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">modulus</span><span class="p">()</span>
    <span class="n">argument</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">arg</span><span class="p">()</span>

    <span class="c1"># Lastly, try out in-place arithmetic.</span>
    <span class="n">new_sum</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_diff</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_prod</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">new_sum</span> <span class="o">+=</span> <span class="n">w</span>
    <span class="n">new_diff</span> <span class="o">-=</span> <span class="n">w</span>
    <span class="n">new_prod</span> <span class="o">*=</span> <span class="n">w</span>

    <span class="c1"># Print all of the results to the screen.</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z = </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;w = </span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;-z = </span><span class="si">{</span><span class="n">neg_z</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z + w = </span><span class="si">{</span><span class="n">summ</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z - w = </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z * w = </span><span class="si">{</span><span class="n">prod</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;4 * z = </span><span class="si">{</span><span class="n">left_scale</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z * 4 = </span><span class="si">{</span><span class="n">right_scale</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;|z| = </span><span class="si">{</span><span class="n">magnitude</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arg(z) = </span><span class="si">{</span><span class="n">argument</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z += w -&gt; </span><span class="si">{</span><span class="n">new_sum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z -= w -&gt; </span><span class="si">{</span><span class="n">new_diff</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z *= w -&gt; </span><span class="si">{</span><span class="n">new_prod</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

<h2 id="python-1">Python<br /></h2>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">################################################################################</span>
<span class="sd">#                                   LICENSE                                    #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="sd">#   redistribute it and/or modify it under the terms of the GNU General        #</span>
<span class="sd">#   Public License as published by the Free Software Foundation, either        #</span>
<span class="sd">#   version 3 of the License, or (at your option) any later version.           #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is distributed in the hope that      #</span>
<span class="sd">#   it will be useful but WITHOUT ANY WARRANTY; without even the implied       #</span>
<span class="sd">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.           #</span>
<span class="sd">#   See the GNU General Public License for more details.                       #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   You should have received a copy of the GNU General Public License          #</span>
<span class="sd">#   along with mitx_mathematics_programming_examples. If not, see              #</span>
<span class="sd">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Purpose:                                                                   #</span>
<span class="sd">#       Implements complex numbers using a Python class.                       #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Author: Ryan Maguire                                                       #</span>
<span class="sd">#   Date:   2024/11/05                                                         #</span>
<span class="sd">################################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># The modulus and principal argument of a complex number are computed using</span>
<span class="c1"># the square root function and the arctan function. These are found here.</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class:</span>
<span class="sd">            Complex</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Python class for working with complex numbers.</span>
<span class="sd">            This contains methods (functions) for working with</span>
<span class="sd">            common routines found in complex analysis, and</span>
<span class="sd">            implements the basics of complex arithmetic.</span>
<span class="sd">        Attributes:</span>
<span class="sd">            real (float):</span>
<span class="sd">                The real part of the complex number.</span>
<span class="sd">            imag (float):</span>
<span class="sd">                The imaginary part of the complex number.</span>
<span class="sd">        Operators:</span>
<span class="sd">            + (complex addition)</span>
<span class="sd">            += (in-place complex addition)</span>
<span class="sd">            - (complex subtraction)</span>
<span class="sd">            -= (in-place complex subtraction)</span>
<span class="sd">            * (complex multiplication)</span>
<span class="sd">            *= (in-place complex multiplication)</span>
<span class="sd">            / (complex division)</span>
<span class="sd">            /= (in-place complex division)</span>
<span class="sd">            - (unary operator, complex negation)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                __init__</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Creates an instance of the Complex class.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                real (float):</span>
<span class="sd">                    The real part of the complex number.</span>
<span class="sd">                imag (float):</span>
<span class="sd">                    The imaginary part of the complex number.</span>
<span class="sd">            Output:</span>
<span class="sd">                z (Complex):</span>
<span class="sd">                    The complex number real + i*imag</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Both inputs should be &quot;floats&quot;, which are real numbers in a computer.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">imag</span><span class="p">)</span>

        <span class="c1"># If we can&#39;t convert the inputs into floats, the user gave invalid</span>
        <span class="c1"># inputs. Treat this as an error.</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;A complex number is created from two real numbers.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="c1"># + operator for complex addition.</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Addition (+).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex addition.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being added to self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                sum (Complex):</span>
<span class="sd">                    The complex sum of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Add the complex numbers component-wise. If self and other</span>
<span class="sd">                are represented as z = a + ib and w = c + id,</span>
<span class="sd">                respectively, the sum is then:</span>

<span class="sd">                    z + w = (a + ib) + (c + id)</span>
<span class="sd">                          = (a + c) + i(b + d)</span>

<span class="sd">                That is, complex addition is done component-wise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We can only add complex numbers and real numbers together. Check if</span>
        <span class="c1"># the input is either of these.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot add.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here, the input was a real number. We can add.</span>
            <span class="n">real_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">other_real</span>
            <span class="n">imag_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_sum</span><span class="p">,</span> <span class="n">imag_sum</span><span class="p">)</span>

        <span class="c1"># If we get here, the input is a complex number. Add the components.</span>
        <span class="n">real_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_sum</span><span class="p">,</span> <span class="n">imag_sum</span><span class="p">)</span>

    <span class="c1"># += operator for complex addition.</span>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Addition (+=).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex addition in-place.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being added to self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                self</span>
<span class="sd">            Method:</span>
<span class="sd">                Perform complex addition component-wise and store</span>
<span class="sd">                the result in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Similar error check to the one found in __add__.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot add.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># If we get here, the input is a complex number. Add the components.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># - operator for complex subtraction.</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Subtraction (-).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex subtraction.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being subtracted from self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                diff (Complex):</span>
<span class="sd">                    The complex difference of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Subtract the complex numbers component-wise. If self</span>
<span class="sd">                and other are represented as z = a + ib and w = c + id,</span>
<span class="sd">                respectively, the difference is then:</span>

<span class="sd">                    z - w = (a + ib) - (c + id)</span>
<span class="sd">                          = (a - c) + i(b - d)</span>

<span class="sd">                That is, complex subtraction is done component-wise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We can only subtract complex numbers and real numbers. Check if</span>
        <span class="c1"># the input is either of these.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot subtract.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here, the input was a real number. We can subtract.</span>
            <span class="n">real_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">other_real</span>
            <span class="n">imag_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_diff</span><span class="p">,</span> <span class="n">imag_diff</span><span class="p">)</span>

        <span class="c1"># If we get here, the input is a complex number. Subtract components.</span>
        <span class="n">real_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_diff</span><span class="p">,</span> <span class="n">imag_diff</span><span class="p">)</span>

    <span class="c1"># -= operator for complex subtraction.</span>
    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Subtraction (-=).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex subtraction in-place.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    The complex number being subtracted from self.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                self</span>
<span class="sd">            Method:</span>
<span class="sd">                Perform complex subtraction component-wise and store</span>
<span class="sd">                the result in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Subtraction can be done with real or complex numbers.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>

            <span class="c1"># The input is not a complex number. See if it is a real number.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot subtract.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># If we get here, the input is a complex number. Subtract components.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">-=</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># * operator for complex multiplication.</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Multiplication (*).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex multiplication.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    A complex number.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                prod (Complex):</span>
<span class="sd">                    The product of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Complex multiplication is computed using i^2 = -1.</span>
<span class="sd">                That is, if z = a + ib, and w = c + id, then:</span>

<span class="sd">                    z*w = (a + ib) * (c + id)</span>
<span class="sd">                        = ac + ibc + iad + i^2bd</span>
<span class="sd">                        = (ac - bd) + i(ad + bc)</span>

<span class="sd">                If other is purely real, this is just scalar multiplication.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The input must be a real or complex number.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot multiply.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here the input was a real number. Multiply components.</span>
            <span class="n">prod_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other_real</span>
            <span class="n">prod_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other_real</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

        <span class="c1"># If we get here, the input was complex.</span>
        <span class="n">prod_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">prod_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

    <span class="c1"># * operator for complex multiplication on the right.</span>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Multiplication (*).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex multiplication (on the right).</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    A complex number.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                prod (Complex):</span>
<span class="sd">                    The product of self and other.</span>
<span class="sd">            Method:</span>
<span class="sd">                Complex multiplication is commutative, so this operator</span>
<span class="sd">                does the same thing as multiplication on the left.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The input must be a real or complex number.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot multiply.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here the input was a real number. Multiply components.</span>
            <span class="n">prod_real</span> <span class="o">=</span> <span class="n">other_real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>
            <span class="n">prod_imag</span> <span class="o">=</span> <span class="n">other_real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

        <span class="c1"># If we get here, the input was complex.</span>
        <span class="n">prod_real</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">prod_imag</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">prod_real</span><span class="p">,</span> <span class="n">prod_imag</span><span class="p">)</span>

    <span class="c1"># *= operator for complex multiplication.</span>
    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Multiplication (*=).</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Performs complex multiplication in-place.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                other (Complex):</span>
<span class="sd">                    A complex number.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Performing complex multiplication naively in-place will</span>
<span class="sd">                overwrite the real part first, meaning the imaginary part</span>
<span class="sd">                will get the wrong input. We correct this by saving the</span>
<span class="sd">                real part as a new variable, and performing complex</span>
<span class="sd">                multiplication with this.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The input must be a real or complex number.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_real</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input is not real or complex. Cannot multiply.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># If we get here the input was a real number. Multiply components.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*=</span> <span class="n">other_real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*=</span> <span class="n">other_real</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># If we get here, the input was complex. Avoid overwriting data,</span>
        <span class="c1"># save the real part of self before computing.</span>
        <span class="n">self_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># We can now perform the product.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">self_real</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># Negation operator.</span>
    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Operator:</span>
<span class="sd">                Negation (-):</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Negates a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Outputs:</span>
<span class="sd">                neg_self (Complex):</span>
<span class="sd">                    The negation of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Negate each component and return.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Negate all components and return.</span>
        <span class="n">real_val</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_val</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real_val</span><span class="p">,</span> <span class="n">imag_val</span><span class="p">)</span>

    <span class="c1"># Complex conjugation.</span>
    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                conj</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Computes the complex conjugate of a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                conj_self (Complex):</span>
<span class="sd">                    The complex conjugate of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Negate the imaginary part and return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="c1"># Computes the complex modulus, or magnitude, of a complex number.</span>
    <span class="k">def</span> <span class="nf">modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                modulus</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Computes the complex modulus of a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                abs_z (Complex):</span>
<span class="sd">                    The magnitude of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Use the Pythagorean formula.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Pythagorean formula: Square root of the sum of the squares.</span>
        <span class="n">real_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imag_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">real_squared</span> <span class="o">+</span> <span class="n">imag_squared</span><span class="p">)</span>

    <span class="c1"># Computes the principal argument of a complex number.</span>
    <span class="k">def</span> <span class="nf">arg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                arg</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Computes the principal argument of a complex number.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                arg_z (Complex):</span>
<span class="sd">                    The principal argument of self.</span>
<span class="sd">            Method:</span>
<span class="sd">                Use the atan2 function from the math module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="c1"># Used for copying an instance of a complex number into a new variable.</span>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                copy</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Copies the data of self to a new variable.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                self_copy (Complex):</span>
<span class="sd">                    A copy of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="c1"># Converts a complex number into a string.</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function:</span>
<span class="sd">                __str__</span>
<span class="sd">            Purpose:</span>
<span class="sd">                Converts a complex number into a string. Used for printing.</span>
<span class="sd">            Arguments:</span>
<span class="sd">                None.</span>
<span class="sd">            Output:</span>
<span class="sd">                self_string (str):</span>
<span class="sd">                    String representation of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the imaginary part is negative, write real - |imag| i, instead</span>
        <span class="c1"># of writing real + -imag i.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="si">}</span><span class="s1"> i&#39;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="si">}</span><span class="s1"> + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="si">}</span><span class="s1"> i&#39;</span>

<span class="c1"># Let&#39;s test our routines.</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="c1"># Two test complex numbers to play with.</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Test out negation.</span>
    <span class="n">neg_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span>

    <span class="c1"># Test out complex arithmetic.</span>
    <span class="n">summ</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">w</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">w</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">w</span>

    <span class="c1"># And try scalar multiplication.</span>
    <span class="n">right_scale</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="mf">4.0</span>
    <span class="n">left_scale</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">z</span>

    <span class="c1"># Test basic complex functions.</span>
    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">modulus</span><span class="p">()</span>
    <span class="n">argument</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">arg</span><span class="p">()</span>

    <span class="c1"># Lastly, try out in-place arithmetic.</span>
    <span class="n">new_sum</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_diff</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_prod</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">new_sum</span> <span class="o">+=</span> <span class="n">w</span>
    <span class="n">new_diff</span> <span class="o">-=</span> <span class="n">w</span>
    <span class="n">new_prod</span> <span class="o">*=</span> <span class="n">w</span>

    <span class="c1"># Print all of the results to the screen.</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z = </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;w = </span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;-z = </span><span class="si">{</span><span class="n">neg_z</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z + w = </span><span class="si">{</span><span class="n">summ</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z - w = </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z * w = </span><span class="si">{</span><span class="n">prod</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;4 * z = </span><span class="si">{</span><span class="n">left_scale</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z * 4 = </span><span class="si">{</span><span class="n">right_scale</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;|z| = </span><span class="si">{</span><span class="n">magnitude</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arg(z) = </span><span class="si">{</span><span class="n">argument</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z += w -&gt; </span><span class="si">{</span><span class="n">new_sum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z -= w -&gt; </span><span class="si">{</span><span class="n">new_diff</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z *= w -&gt; </span><span class="si">{</span><span class="n">new_prod</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

<h2 id="c-1">C<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Provides basic syntax for complex numbers using the C89 standard.     *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2024/11/04                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  As before, stdio.h provides the &quot;printf&quot; function.                        */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cm">/*  The standard library provides sqrt and atan2. sqrt computes the square    *</span>
<span class="cm"> *  root of a non-negative real number, and atan2 computes the angle the      *</span>
<span class="cm"> *  point (x, y) in the plane makes with the x axis.                          */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>

<span class="cm">/*  Mimicing other programming libraries, let&#39;s define a complex number as an *</span>
<span class="cm"> *  ordered pair of real numbers.                                             */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">real</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">imag</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">complex</span><span class="p">;</span>

<span class="cm">/*  UNIMPORTANT NOTE.                                                         *</span>
<span class="cm"> *      Every function to follow (except main) will have the word &quot;static&quot;    *</span>
<span class="cm"> *      before it. This simply means the function is only used in this file.  *</span>
<span class="cm"> *      Since this is a small demo, and not a programming library, every      *</span>
<span class="cm"> *      function is declared &quot;static.&quot; Doing this makes compilers happier.    *</span>
<span class="cm"> *      The student can simply ignore this keyword.                           */</span>

<span class="cm">/*  This function computes the real part of a complex number. It is           *</span>
<span class="cm"> *  equivalent to Re(z) in our notation.                                      */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">real_part</span><span class="p">(</span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  To access the elements in our &quot;struct&quot;, we use dot notation.          *</span>
<span class="cm">     *  z is a struct with variables &quot;real&quot; and &quot;imag&quot; stored inside.         *</span>
<span class="cm">     *  To access the &quot;real&quot; variable, we write z.real.                       *</span>
<span class="cm">     *  Return this to compute the real part of z.                            */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  Similarly, this function computes Im(z).                                  */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">imag_part</span><span class="p">(</span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  To access imag, write z.imag.                                         */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">imag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  This function computes the magnitude of z.                                */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">modulus</span><span class="p">(</span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  Use the Pythagorean formula to compute |z|.                           */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">real_squared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">real</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">imag_squared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">imag</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">imag</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Pythagoras: Square root of the sum of the squares.                    */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">real_squared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">imag_squared</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  Computes the principal argument of z.                                     */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">principal_argument</span><span class="p">(</span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  math.h provides atan2, which computes the angle the point (x, y)      *</span>
<span class="cm">     *  makes with the positive x axis. This is the unique number theta, with *</span>
<span class="cm">     *  -pi &lt; theta &lt;= pi, that contains (x, y) on the ray of angle theta. By *</span>
<span class="cm">     *  convention, atan2(0, 0) = 0.                                          *</span>
<span class="cm">     *                                                                        *</span>
<span class="cm">     *  NOTE:                                                                 *</span>
<span class="cm">     *      The syntax is theta = atan2(y, x). DO NOT WRITE atan2(x, y).      */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">atan2</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">real</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  Same routine as before, printing out some values using our new functions. */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  Lacking a compiler that implements complex numbers directly, we       *</span>
<span class="cm">     *  create complex numbers using &quot;struct&quot; syntax. This looks as follows.  */</span>
<span class="w">    </span><span class="k">complex</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">};</span><span class="w"> </span><span class="cm">/* This is z = 1 + i. */</span>

<span class="w">    </span><span class="cm">/*  Get the real and imaginary parts of z.                                */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">real_part</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">imag_part</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  And get the polar form of z.                                          */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modulus</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">theta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">principal_argument</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Print everything to the screen, just as before.                       */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;z = %f + %f i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;|z| = |%f + %f i| = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Arg(z) = Arg(%f + %f i) = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">theta</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ryan Maguire</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ryan Maguire</li><li><a class="u-email" href="mailto:rmaguire@protonmail.com">rmaguire@protonmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ryanmaguire"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ryanmaguire</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Mathematics, Physics, and Programming</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
