<div class="highlight"><pre><span></span><span class="c">################################################################################</span>
<span class="c">#                                   LICENSE                                    #</span>
<span class="c">################################################################################</span>
<span class="c">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="c">#   redistribute it and/or modify it under the terms of the GNU General Public #</span>
<span class="c">#   License as published by the Free Software Foundation, either version 3 of  #</span>
<span class="c">#   the License, or (at your option) any later version.                        #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is distributed in the hope that it   #</span>
<span class="c">#   will be useful, but WITHOUT ANY WARRANTY; without even the implied         #</span>
<span class="c">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  #</span>
<span class="c">#   GNU General Public License for more details.                               #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   You should have received a copy of the GNU General Public License          #</span>
<span class="c">#   along with mitx_mathematics_programming_examples.  If not, see             #</span>
<span class="c">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="c">################################################################################</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Calculates square roots using Heron&#39;s method.                          #</span>
<span class="c">################################################################################</span>
<span class="c">#   Author:     Ryan Maguire                                                   #</span>
<span class="c">#   Date:       March 9, 2025.                                                 #</span>
<span class="c">################################################################################</span>

<span class="c">################################################################################</span>
<span class="c">#   Function:                                                                  #</span>
<span class="c">#       herons_method                                                          #</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Computes square roots of positive real numbers using Heron&#39;s method.   #</span>
<span class="c">#   Arguments:                                                                 #</span>
<span class="c">#       x (real):                                                              #</span>
<span class="c">#           A positive real number, the input to the square root function.     #</span>
<span class="c">#   Output:                                                                    #</span>
<span class="c">#       sqrt_x (real):                                                         #</span>
<span class="c">#           The square root of the input.                                      #</span>
<span class="c">################################################################################</span>
<span class="k">function</span><span class="w"> </span><span class="n">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Heron&#39;s method is iterative and the convergence is quadratic. This</span>
<span class="w">    </span><span class="c"># means that if a_{n} has N correct decimals, then a_{n+1} will have</span>
<span class="w">    </span><span class="c"># 2N correct decimals. A standard 64-bit double can fit about 16</span>
<span class="w">    </span><span class="c"># decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).</span>
<span class="w">    </span><span class="c"># Because of this we may exit the function after a few iterations.</span>
<span class="w">    </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span>

<span class="w">    </span><span class="c"># The maximum allowed error. This is 4x double precision epsilon.</span>
<span class="w">    </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span>

<span class="w">    </span><span class="c"># Set the initial guess to the input. Provided x is positive, Heron&#39;s</span>
<span class="w">    </span><span class="c"># method will indeed converge.</span>
<span class="w">    </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>

<span class="w">    </span><span class="c"># Iteratively apply Heron&#39;s method.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">maximum_number_of_iterations</span>

<span class="w">        </span><span class="c"># If the error is small we can break out of this for-loop. Check.</span>
<span class="w">        </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c"># Otherwise improve the approximation using Heron&#39;s method.</span>
<span class="w">        </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximate_root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># As long as x is positive and not very large, we should have a very</span>
<span class="w">    </span><span class="c"># good approximation for sqrt(x). Heron&#39;s method will still work for</span>
<span class="w">    </span><span class="c"># very large x, but we must increase maximum_number_of_iterations.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">approximate_root</span>

<span class="k">end</span>

<span class="c"># Test out our implementation by computing the square root of 2.</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span>
<span class="n">sqrt_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;sqrt(&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;) = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt_x</span><span class="p">)</span>

<span class="c"># We can run this on GNU, Linux, FreeBSD, macOS, Windows, etc.</span>
<span class="c"># First install Julia:</span>
<span class="c">#   https://julialang.org/downloads/</span>
<span class="c"># Once installed, type:</span>
<span class="c">#   julia herons_method.jl</span>
<span class="c"># This will output:</span>
<span class="c">#   sqrt(2.0) = 1.414213562373095</span>
<span class="c"># This has a relative error of 1.570092458683775E-16.</span>
</pre></div>
