<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ryan Maguire | Mathematics, Physics, and Programming</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Ryan Maguire" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Mathematics, Physics, and Programming" />
<meta property="og:description" content="Mathematics, Physics, and Programming" />
<link rel="canonical" href="https://github.com/ryanmaguire/programming/real_analysis/real_numbers/herons_method/" />
<meta property="og:url" content="https://github.com/ryanmaguire/programming/real_analysis/real_numbers/herons_method/" />
<meta property="og:site_name" content="Ryan Maguire" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ryan Maguire" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Mathematics, Physics, and Programming","headline":"Ryan Maguire","url":"https://github.com/ryanmaguire/programming/real_analysis/real_numbers/herons_method/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://github.com/ryanmaguire/feed.xml" title="Ryan Maguire" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Ryan Maguire</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/asymptote/">Asymptote</a><a class="page-link" href="/papers/">Papers</a><a class="page-link" href="/presentations/">Presentations</a><a class="page-link" href="/programming/">Programming</a><a class="page-link" href="/projects/">Projects</a><a class="page-link" href="/teaching/">Teaching</a><a class="page-link" href="/threejs/">Three.js</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <p><a href="../"><strong>Back</strong></a></p>

<h2 id="c">C<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/08                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  stdio.h provides the &quot;printf&quot; function, used for printing text.           */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cm">/*  Floating-point absolute value function, fabs, provided here.              */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>

<span class="cm">/*  Computes the square root of a positive real number via Heron&#39;s method.    */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">herons_method</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      *</span>
<span class="cm">     *                                                                        *</span>
<span class="cm">     *  Note:                                                                 *</span>
<span class="cm">     *      We are declaring the following integer as &quot;unsigned&quot; meaning      *</span>
<span class="cm">     *      non-negative. The &quot;U&quot; after the number is the suffix for unsigned *</span>
<span class="cm">     *      constants in C. It simply means unsigned.                         */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is 4x double precision epsilon.       */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of how many iterations we have performed.  */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Set the initial guess to the input. Provided x is positive, Heron&#39;s   *</span>
<span class="cm">     *  method will indeed converge.                                          */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Iteratively loop through and obtain better approximations for sqrt(x).*/</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  If we are within epsilon of the correct value we may break out of *</span>
<span class="cm">         *  this for-loop. Use the absolute value function to check.          */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Apply Heron&#39;s method to get a better approximation for the root.  */</span>
<span class="w">        </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximate_root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  As long as x is positive and not very large, we should have a very    *</span>
<span class="cm">     *  good approximation for sqrt(x). Heron&#39;s method will still work for    *</span>
<span class="cm">     *  very large x, but we must increase maximum_number_of_iterations.      */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of herons_method.                                                     */</span>

<span class="cm">/*  Main routine used for testing our implementation of Heron&#39;s method.       */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  The input to Heron&#39;s method, the value we want to compute the square  *</span>
<span class="cm">     *  root of.                                                              */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Calculate the square root and print it to the screen. If we have      *</span>
<span class="cm">     *  written things correctly, we should get 1.414..., which is sqrt(2).   */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sqrt_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sqrt(%.1f) = %.16f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt_x</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  We can execute this on GNU, Linux, FreeBSD, macOS, etc., via:             *</span>
<span class="cm"> *      cc herons_method.c -o main                                            *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  This will output the following:                                           *</span>
<span class="cm"> *      sqrt(2.0) = 1.4142135623730949                                        *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On Windows you will need to install a C compiler. Common options are      *</span>
<span class="cm"> *  Microsoft&#39;s MSVC, LLVM&#39;s clang, MinGW (which uses the GNU toolchain),     *</span>
<span class="cm"> *  or installing Cygwin and running the commands above. Using MSVC, type:    *</span>
<span class="cm"> *      cl herons_method.c /link /out:main.exe                                *</span>
<span class="cm"> *      main.exe                                                              *</span>
<span class="cm"> *  This will produce the same output.                                        */</span>
</pre></div>

<h2 id="c3">C3<br /></h2>

<h2 id="c-1">C++<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/08                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  stdio provides the &quot;printf&quot; function, used for printing text.             */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="cm">/*  Floating-point absolute value function, fabs, provided here.              */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>

<span class="cm">/*  Class providing an implementation of sqrt using Heron&#39;s method.           */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Heron</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      *</span>
<span class="cm">     *                                                                        *</span>
<span class="cm">     *  Note:                                                                 *</span>
<span class="cm">     *      We are declaring the following integer as &quot;unsigned&quot; meaning      *</span>
<span class="cm">     *      non-negative. The &quot;U&quot; after the number is the suffix for unsigned *</span>
<span class="cm">     *      constants in C++. It simply means unsigned.                       */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  We want the function visible outside the class. Declare it public.    */</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>

<span class="w">        </span><span class="cm">/*  Computes square roots of positive real numbers via Heron&#39;s method.*</span>
<span class="cm">         *  We are declaring this inside of the Heron class, so there should  *</span>
<span class="cm">         *  be no naming conflict with std::sqrt, the standard square root.   */</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  Maximum allowed error. This is 4x double precision epsilon.   */</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Variable for keeping track of the number of iterations.       */</span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Set the initial guess to the input. Provided x is positive,   *</span>
<span class="cm">             *  Heron&#39;s method will indeed converge.                          */</span>
<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Iteratively loop through and obtain better approximations.    */</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/*  If we are within epsilon of the correct value we may      *</span>
<span class="cm">                 *  break out of this for-loop. Check the relative error.     */</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximate_root</span><span class="o">*</span><span class="n">approximate_root</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">;</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/*  Apply Heron&#39;s method to get a better approximation.       */</span>
<span class="w">                </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">approximate_root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="o">/</span><span class="n">approximate_root</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/*  As long as x is positive and not very large, we should have a *</span>
<span class="cm">             *  very good approximation for sqrt(x). Heron&#39;s method will      *</span>
<span class="cm">             *  still work for very large x, but we must increase the value   *</span>
<span class="cm">             *  of maximum_number_of_iterations.                              */</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cm">/*  End of sqrt.                                                      */</span>
<span class="p">};</span>
<span class="cm">/*  End of Heron definition.                                                  */</span>

<span class="cm">/*  Main routine used for testing our implementation of Heron&#39;s method.       */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  The input to Heron&#39;s method, the value we want to compute the square  *</span>
<span class="cm">     *  root of.                                                              */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Calculate the square root and print it to the screen. If we have      *</span>
<span class="cm">     *  written things correctly, we should get 1.414..., which is sqrt(2).   */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sqrt_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Heron</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sqrt(%.1f) = %.16f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt_x</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  We can execute this on GNU, Linux, FreeBSD, macOS, etc., via:             *</span>
<span class="cm"> *      c++ herons_method.cpp -o main                                         *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  This will output the following:                                           *</span>
<span class="cm"> *      sqrt(2.0) = 1.4142135623730949                                        *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On Windows you will need to install a C++ compiler. Microsoft&#39;s MSVC is a *</span>
<span class="cm"> *  common option. Using MSVC, type:                                          *</span>
<span class="cm"> *      cl herons_method.cpp /link /out:main.exe                              *</span>
<span class="cm"> *      main.exe                                                              *</span>
<span class="cm"> *  This will produce the same output.                                        */</span>
</pre></div>

<h2 id="c-2">C#<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/08                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Console.WriteLine and Math.Abs are both provided here.                    */</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="cm">/*  Class providing an implementation of Heron&#39;s method.                      */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Heron</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      *</span>
<span class="cm">     *                                                                        *</span>
<span class="cm">     *  Note:                                                                 *</span>
<span class="cm">     *      We are declaring the following integer as &quot;unsigned&quot; meaning      *</span>
<span class="cm">     *      non-negative. The &quot;U&quot; after the number is the suffix for unsigned *</span>
<span class="cm">     *      constants in C#. It simply means unsigned.                        */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">16</span><span class="n">U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is 4x double precision epsilon.       */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">8.881784197001252E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Computes square roots using Heron&#39;s method.                           */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">HeronsMethod</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Dummy variable for keeping track of the number of iterations.     */</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Initial approximation for Heron&#39;s method. Choose the input.       */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">approximateRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Loop through and iteratively apply Heron&#39;s method.                */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  If we are within epsilon of the correct value we may break    *</span>
<span class="cm">             *  break out of this for-loop. Check for this.                   */</span>
<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximateRoot</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">approximateRoot</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Otherwise, improve our approximation using Heron&#39;s method.    */</span>
<span class="w">            </span><span class="n">approximateRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximateRoot</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">approximateRoot</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Provided x is positive and not very large, we should have an      *</span>
<span class="cm">         *  excellent approximation for sqrt(x). Heron&#39;s method does indeed   *</span>
<span class="cm">         *  work for large x, but we may need to increase the value of        *</span>
<span class="cm">         *  maximumNumberOfIterations.                                        */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">approximateRoot</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/*  End of HeronsMethod.                                                  */</span>

<span class="w">    </span><span class="cm">/*  Routine for testing our implementation of Heron&#39;s method.             */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Compute sqrt(2) using Heron&#39;s method and print the result.        */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2.0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">sqrtX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HeronsMethod</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;sqrt({x}) = {sqrtX}&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*  On Windows you can use Microsoft&#39;s C# compiler. Type:                     *</span>
<span class="cm"> *      csc herons_method.cs -out:main.exe                                    *</span>
<span class="cm"> *      main.exe                                                              *</span>
<span class="cm"> *  This will output:                                                         *</span>
<span class="cm"> *      sqrt(2) = 1.41421356237309                                            *</span>
<span class="cm"> *  This has a relative error of 3.611212654972683e-15. Note, csc only prints *</span>
<span class="cm"> *  a double to 15 decimals, the last digit is rounded.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On GNU, Linux, FreeBSD, macOS, etc., you can use the mono C# compiler:    *</span>
<span class="cm"> *      mcs herons_method.cs -out:main                                        *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  This produces the same result.                                            */</span>
</pre></div>

<h2 id="d">D<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/08                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Computes the square root of a positive real number via Heron&#39;s method.    */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">herons_method</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="k">pure</span><span class="w"> </span><span class="k">nothrow</span><span class="w"> </span><span class="nd">@safe</span><span class="w"> </span><span class="nd">@nogc</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  We&#39;ll use the absolute value function to compute the relative error.  */</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">math</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">fabs</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">16U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is 4x double precision epsilon.       */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of how many iterations we have performed.  */</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Set the initial guess to the input. Provided x is positive, Heron&#39;s   *</span>
<span class="cm">     *  method will indeed converge.                                          */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Iteratively loop through and obtain better approximations for sqrt(x).*/</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="p">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  If we are within epsilon of the correct value we may break out of *</span>
<span class="cm">         *  this for-loop. Use the absolute value function to check.          */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="p">-</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="p">*</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Apply Heron&#39;s method to get a better approximation for the root.  */</span>
<span class="w">        </span><span class="n">approximate_root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximate_root</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  As long as x is positive and not very large, we should have a very    *</span>
<span class="cm">     *  good approximation for sqrt(x). Heron&#39;s method will still work for    *</span>
<span class="cm">     *  very large x, but we must increase maximum_number_of_iterations.      */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of herons_method.                                                     */</span>

<span class="cm">/*  Main routine used for testing our implementation of Heron&#39;s method.       */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  stdio provides the &quot;printf&quot; function, used for printing text.         */</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">printf</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The input to Heron&#39;s method, the value we want to compute the square  *</span>
<span class="cm">     *  root of.                                                              */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Calculate the square root and print it to the screen. If we have      *</span>
<span class="cm">     *  written things correctly, we should get 1.414..., which is sqrt(2).   */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sqrt_x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sqrt(%.1f) = %.16f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt_x</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  We can run this on GNU, Linux, FreeBSD, etc., using the GNU D compiler,   *</span>
<span class="cm"> *  which is part of the GNU Compiler Collection (GCC), via:                  *</span>
<span class="cm"> *      gdc herons_method.d -o main                                           *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  This will output the following:                                           *</span>
<span class="cm"> *      sqrt(2.0) = 1.4142135623730949                                        *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On macOS and Windows you can install the official D compiler, DMD:        *</span>
<span class="cm"> *      https://dlang.org/download.html                                       *</span>
<span class="cm"> *  Once installed you can compile and run on Windows by typing:              *</span>
<span class="cm"> *      dmd herons_method.d -of=main.exe                                      *</span>
<span class="cm"> *      main.exe                                                              *</span>
<span class="cm"> *  On macOS you can do something similar:                                    *</span>
<span class="cm"> *      dmd herons_method.d -of=main                                          *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  These will produce the same output.                                       */</span>
</pre></div>

<h2 id="fortran">Fortran<br /></h2>
<div class="highlight"><pre><span></span><span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!                                   LICENSE                                    !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!   This file is part of mitx_mathematics_programming_examples.                !</span>
<span class="c">!                                                                              !</span>
<span class="c">!   mitx_mathematics_programming_examples is free software: you can            !</span>
<span class="c">!   redistribute it and/or modify it under the terms of the GNU General Public !</span>
<span class="c">!   License as published by the Free Software Foundation, either version 3 of  !</span>
<span class="c">!   the License, or (at your option) any later version.                        !</span>
<span class="c">!                                                                              !</span>
<span class="c">!   mitx_mathematics_programming_examples is distributed in the hope that it   !</span>
<span class="c">!   will be useful but WITHOUT ANY WARRANTY; without even the implied warranty !</span>
<span class="c">!   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           !</span>
<span class="c">!   GNU General Public License for more details.                               !</span>
<span class="c">!                                                                              !</span>
<span class="c">!   You should have received a copy of the GNU General Public License          !</span>
<span class="c">!   along with mitx_mathematics_programming_examples.  If not, see             !</span>
<span class="c">!   &lt;https://www.gnu.org/licenses/&gt;.                                           !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!   Purpose:                                                                   !</span>
<span class="c">!       Calculates square roots using Heron&#39;s method.                          !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!   Author: Ryan Maguire                                                       !</span>
<span class="c">!   Date:   2025/03/08                                                         !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="k">MODULE </span><span class="n">HERON</span>

<span class="w">    </span><span class="k">IMPLICIT NONE</span>

<span class="w">    </span><span class="c">! Heron&#39;s method is iterative. The convergence is quadratic, meaning the</span>
<span class="w">    </span><span class="c">! number of accurate decimals doubles with each iteration. Because of this</span>
<span class="w">    </span><span class="c">! we can halt the algorithm after a few steps.</span>
<span class="w">    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span>

<span class="w">    </span><span class="c">! Maximum allowed error. This is 4x double precision epsilon.</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">EPSILON</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span>

<span class="w">    </span><span class="k">CONTAINS</span>

<span class="w">    </span><span class="c">!--------------------------------------------------------------------------!</span>
<span class="w">    </span><span class="c">!   Function:                                                              !</span>
<span class="w">    </span><span class="c">!       HERONS_METHOD                                                      !</span>
<span class="w">    </span><span class="c">!   Purpose:                                                               !</span>
<span class="w">    </span><span class="c">!       Computes square roots using Heron&#39;s method.                        !</span>
<span class="w">    </span><span class="c">!   Arguments:                                                             !</span>
<span class="w">    </span><span class="c">!       X (REAL):                                                          !</span>
<span class="w">    </span><span class="c">!           A positive real number.                                        !</span>
<span class="w">    </span><span class="c">!   OUTPUT:                                                                !</span>
<span class="w">    </span><span class="c">!       SQRT_X (REAL):                                                     !</span>
<span class="w">    </span><span class="c">!           The square root of X.                                          !</span>
<span class="w">    </span><span class="c">!--------------------------------------------------------------------------!</span>
<span class="w">    </span><span class="k">FUNCTION </span><span class="n">HERONS_METHOD</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="w">        </span><span class="k">IMPLICIT NONE</span>

<span class="w">        </span><span class="c">! The input is a positive real number.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="p">,</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">X</span>

<span class="w">        </span><span class="c">! The output is also a positive real number, the square root of X.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">HERONS_METHOD</span>

<span class="w">        </span><span class="c">! Dummy variable for keeping track of how many iterations we&#39;ve done.</span>
<span class="w">        </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ITERS</span>

<span class="w">        </span><span class="c">! Variable used for Heron&#39;s approximation. We will iteratively update</span>
<span class="w">        </span><span class="c">! this value with better approximations using Heron&#39;s method.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">APPROXIMATE_ROOT</span>

<span class="w">        </span><span class="c">! Variable for tracking the relative error. When this is very small</span>
<span class="w">        </span><span class="c">! (less than epsilon) we will break out of the loop and return.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ERROR</span>

<span class="w">        </span><span class="c">! Heron&#39;s method needs a starting value. Initialize this to the input.</span>
<span class="w">        </span><span class="n">APPROXIMATE_ROOT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span>

<span class="w">        </span><span class="c">! Iteratively perform Heron&#39;s method.</span>
<span class="w">        </span><span class="k">DO </span><span class="n">ITERS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span>

<span class="w">            </span><span class="c">! If the error is small we can break out of this loop.</span>
<span class="w">            </span><span class="n">ERROR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">APPROXIMATE_ROOT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">APPROXIMATE_ROOT</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">X</span>

<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="n">LT</span><span class="p">.</span><span class="w"> </span><span class="nb">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">                EXIT</span>
<span class="k">            END IF</span>

<span class="w">            </span><span class="c">! Otherwise, improve our approximation using Heron&#39;s method.</span>
<span class="w">            </span><span class="n">APPROXIMATE_ROOT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">APPROXIMATE_ROOT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">APPROXIMATE_ROOT</span><span class="p">)</span>
<span class="w">        </span><span class="k">END DO</span>

<span class="w">        </span><span class="c">! If x is positive and not too big, APPROXIMATE_ROOT should have a</span>
<span class="w">        </span><span class="c">! very accurate approximation to sqrt(x). Heron&#39;s method works for</span>
<span class="w">        </span><span class="c">! large inputs as well, but we need to increase the value of</span>
<span class="w">        </span><span class="c">! MAXIMUM_NUMBER_OF_ITERATIONS.</span>
<span class="w">        </span><span class="n">HERONS_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">APPROXIMATE_ROOT</span>
<span class="w">    </span><span class="k">END FUNCTION </span><span class="n">HERONS_METHOD</span>
<span class="k">END MODULE </span><span class="n">HERON</span>

<span class="c">! Program for testing our implementation of Heron&#39;s method.</span>
<span class="k">PROGRAM </span><span class="n">MAIN</span>

<span class="w">    </span><span class="k">USE </span><span class="n">HERON</span>
<span class="w">    </span><span class="k">IMPLICIT NONE</span>

<span class="w">    </span><span class="c">! The input for the method. We&#39;ll compute sqrt(2).</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span>

<span class="w">    </span><span class="c">! Variable for the output.</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">SQRT_X</span>

<span class="w">    </span><span class="c">! Run the routine, computing sqrt(x), and print the result.</span>
<span class="w">    </span><span class="n">SQRT_X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HERONS_METHOD</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="w">    </span><span class="k">PRINT</span><span class="w"> </span><span class="s2">&quot;(A,F3.1,A,F18.16)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;SQRT(&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;) = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">SQRT_X</span>

<span class="k">END PROGRAM </span><span class="n">MAIN</span>

<span class="c">! You can compile this on GNU, Linux, FreeBSD, macOS, etc., using</span>
<span class="c">! GNU&#39;s Fortran compiler, gfortran. Type:</span>
<span class="c">!   gfortran -fdefault-real-8 herons_method.f90 -o main</span>
<span class="c">!   ./main</span>
<span class="c">! This will output:</span>
<span class="c">!   SQRT(2.0) = 1.4142135623730949</span>
<span class="c">! This has a relative error of 1.570092458683775E-16.</span>
<span class="c">!</span>
<span class="c">! On Windows you can also use gfortran by installing MSYS2:</span>
<span class="c">!   https://www.msys2.org/</span>
<span class="c">! Along with mingw-w64:</span>
<span class="c">!   https://www.mingw-w64.org/getting-started/msys2/</span>
<span class="c">! Once gfortan is installed, you can type:</span>
<span class="c">!   gfortran -fdefault-real-8 herons_method.f90 -o main.exe</span>
<span class="c">!   main.exe</span>
<span class="c">! This will produce the same output.</span>
</pre></div>

<h2 id="go">Go<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/08                                                        *</span>
<span class="cm"> ******************************************************************************/</span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="cm">/*  Only standard library imports are needed.                                 */</span>
<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span><span class="w">   </span><span class="cm">/*  Printf provided here, used for printing text to the screen.   */</span>
<span class="w">    </span><span class="s">&quot;math&quot;</span><span class="w">  </span><span class="cm">/*  Abs, floating-point absolute value function, found here.      */</span>
<span class="p">)</span>

<span class="cm">/*  Computes the square root of a positive real number via Heron&#39;s method.    */</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">herons_method</span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="kt">float64</span><span class="p">)</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">maximum_number_of_iterations</span><span class="w"> </span><span class="kt">uint32</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">16</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is 4x double precision epsilon.       */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">epsilon</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of how many iterations we have performed.  */</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="kt">uint32</span>

<span class="w">    </span><span class="cm">/*  Set the initial guess to the input. Provided x is positive, Heron&#39;s   *</span>
<span class="cm">     *  method will indeed converge.                                          */</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">approximate_root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">x</span>

<span class="w">    </span><span class="cm">/*  Iteratively loop through and obtain better approximations for sqrt(x).*/</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If we are within epsilon of the correct value we may break out of *</span>
<span class="cm">         *  this for-loop. Use the absolute value function to check.          */</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">approximate_root</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">approximate_root</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">x</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">math</span><span class="p">.</span><span class="nx">Abs</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">epsilon</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Apply Heron&#39;s method to get a better approximation for the root.  */</span>
<span class="w">        </span><span class="nx">approximate_root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">approximate_root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">approximate_root</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  As long as x is positive and not very large, we should have a very    *</span>
<span class="cm">     *  good approximation for sqrt(x). Heron&#39;s method will still work for    *</span>
<span class="cm">     *  very large x, but we must increase maximum_number_of_iterations.      */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">approximate_root</span>
<span class="p">}</span>
<span class="cm">/*  End of herons_method.                                                     */</span>

<span class="cm">/*  Main routine used for testing our implementation of Heron&#39;s method.       */</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  The input to Heron&#39;s method, the value we want to compute the square  *</span>
<span class="cm">     *  root of.                                                              */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">2.0</span>

<span class="w">    </span><span class="cm">/*  Calculate the square root and print it to the screen. If we have      *</span>
<span class="cm">     *  written things correctly, we should get 1.414..., which is sqrt(2).   */</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">sqrt_x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">herons_method</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;sqrt(%.1f) = %.16f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">sqrt_x</span><span class="p">)</span>
<span class="p">}</span>

<span class="cm">/*  We can run this on GNU, Linux, FreeBSD, etc., using the GNU Go compiler,  *</span>
<span class="cm"> *  which is part of the GNU Compiler Collection (GCC), via:                  *</span>
<span class="cm"> *      gccgo herons_method.go -o main                                        *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  This will output the following:                                           *</span>
<span class="cm"> *      sqrt(2.0) = 1.4142135623730949                                        *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On macOS and Windows you can install Google&#39;s official Go compiler:       *</span>
<span class="cm"> *      https://go.dev/                                                       *</span>
<span class="cm"> *  Once installed you can compile and run by typing:                         *</span>
<span class="cm"> *      go run herons_method.go                                               *</span>
<span class="cm"> *  This will produce the same output.                                        */</span>
</pre></div>

<h2 id="java">Java<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/08                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Implementation of sqrt using Heron&#39;s method.                              */</span>
<span class="kd">final</span><span class="w"> </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Heron</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      */</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is 4x double precision epsilon.       */</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Function for computing the square root of a positive real number      *</span>
<span class="cm">     *  using Heron&#39;s method.                                                 */</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">heronsMethod</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Dummy variable for keeping track of the number of iterations.     */</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Starting value for Heron&#39;s method. The input will suffice.        */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Loop through and iteratively perform Heron&#39;s method.              */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  If the error is small enough we can break out of the loop. We *</span>
<span class="cm">             *  want small relative error, so compute this.                   */</span>
<span class="w">            </span><span class="kd">final</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">abs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Otherwise improve the error by applying Heron&#39;s method.       */</span>
<span class="w">            </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximate_root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  As long as x is positive and not very large, we should have a     *</span>
<span class="cm">         *  very good approximation for sqrt(x). Heron&#39;s method works for     *</span>
<span class="cm">         *  large x, but we may need to increase maximum_number_of_iterations.*/</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Main routine for testing our implementation of Heron&#39;s method.        */</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Test out Heron&#39;s method by computing sqrt(2).                     */</span>
<span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sqrt_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Heron</span><span class="p">.</span><span class="na">heronsMethod</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">printf</span><span class="p">(</span><span class="s">&quot;sqrt(%.1f) = %.16f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt_x</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*  We can execute this on GNU, Linux, FreeBSD, macOS, Windows, etc., using   *</span>
<span class="cm"> *  OpenJDK. After installing, type:                                          *</span>
<span class="cm"> *      java herons_method.java                                               *</span>
<span class="cm"> *  This will output the following:                                           *</span>
<span class="cm"> *      sqrt(2.0) = 1.4142135623730950                                        *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       */</span>
</pre></div>

<h2 id="julia">Julia<br /></h2>
<div class="highlight"><pre><span></span><span class="c">################################################################################</span>
<span class="c">#                                   LICENSE                                    #</span>
<span class="c">################################################################################</span>
<span class="c">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="c">#   redistribute it and/or modify it under the terms of the GNU General Public #</span>
<span class="c">#   License as published by the Free Software Foundation, either version 3 of  #</span>
<span class="c">#   the License, or (at your option) any later version.                        #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is distributed in the hope that it   #</span>
<span class="c">#   will be useful, but WITHOUT ANY WARRANTY; without even the implied         #</span>
<span class="c">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  #</span>
<span class="c">#   GNU General Public License for more details.                               #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   You should have received a copy of the GNU General Public License          #</span>
<span class="c">#   along with mitx_mathematics_programming_examples.  If not, see             #</span>
<span class="c">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="c">################################################################################</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Calculates square roots using Heron&#39;s method.                          #</span>
<span class="c">################################################################################</span>
<span class="c">#   Author:     Ryan Maguire                                                   #</span>
<span class="c">#   Date:       March 9, 2025.                                                 #</span>
<span class="c">################################################################################</span>

<span class="c">################################################################################</span>
<span class="c">#   Function:                                                                  #</span>
<span class="c">#       herons_method                                                          #</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Computes square roots of positive real numbers using Heron&#39;s method.   #</span>
<span class="c">#   Arguments:                                                                 #</span>
<span class="c">#       x (real):                                                              #</span>
<span class="c">#           A positive real number, the input to the square root function.     #</span>
<span class="c">#   Output:                                                                    #</span>
<span class="c">#       sqrt_x (real):                                                         #</span>
<span class="c">#           The square root of the input.                                      #</span>
<span class="c">################################################################################</span>
<span class="k">function</span><span class="w"> </span><span class="n">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Heron&#39;s method is iterative and the convergence is quadratic. This</span>
<span class="w">    </span><span class="c"># means that if a_{n} has N correct decimals, then a_{n+1} will have</span>
<span class="w">    </span><span class="c"># 2N correct decimals. A standard 64-bit double can fit about 16</span>
<span class="w">    </span><span class="c"># decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).</span>
<span class="w">    </span><span class="c"># Because of this we may exit the function after a few iterations.</span>
<span class="w">    </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span>

<span class="w">    </span><span class="c"># The maximum allowed error. This is 4x double precision epsilon.</span>
<span class="w">    </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span>

<span class="w">    </span><span class="c"># Set the initial guess to the input. Provided x is positive, Heron&#39;s</span>
<span class="w">    </span><span class="c"># method will indeed converge.</span>
<span class="w">    </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>

<span class="w">    </span><span class="c"># Iteratively apply Heron&#39;s method.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">maximum_number_of_iterations</span>

<span class="w">        </span><span class="c"># If the error is small we can break out of this for-loop. Check.</span>
<span class="w">        </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c"># Otherwise improve the approximation using Heron&#39;s method.</span>
<span class="w">        </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximate_root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># As long as x is positive and not very large, we should have a very</span>
<span class="w">    </span><span class="c"># good approximation for sqrt(x). Heron&#39;s method will still work for</span>
<span class="w">    </span><span class="c"># very large x, but we must increase maximum_number_of_iterations.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">approximate_root</span>

<span class="k">end</span>

<span class="c"># Test out our implementation by computing the square root of 2.</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span>
<span class="n">sqrt_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;sqrt(&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;) = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt_x</span><span class="p">)</span>

<span class="c"># We can run this on GNU, Linux, FreeBSD, macOS, Windows, etc.</span>
<span class="c"># First install Julia:</span>
<span class="c">#   https://julialang.org/downloads/</span>
<span class="c"># Once installed, type:</span>
<span class="c">#   julia herons_method.jl</span>
<span class="c"># This will output:</span>
<span class="c">#   sqrt(2.0) = 1.414213562373095</span>
<span class="c"># This has a relative error of 1.570092458683775E-16.</span>
</pre></div>

<h2 id="javascript">JavaScript<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/05/18                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Computes the square root of a positive real number via Heron&#39;s method.    */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">heronsMethod</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is 4x double precision epsilon.       */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">EPSILON</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of how many iterations we have performed.  */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">iters</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Set the initial guess to the input. Provided x is positive, Heron&#39;s   *</span>
<span class="cm">     *  method will indeed converge.                                          */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Iteratively loop through and obtain better approximations for sqrt(x).*/</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="nx">iters</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If we are within epsilon of the correct value we may break out of *</span>
<span class="cm">         *  this for-loop. Use the absolute value function to check.          */</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Apply Heron&#39;s method to get a better approximation for the root.  */</span>
<span class="w">        </span><span class="nx">approximateRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">approximateRoot</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  As long as x is positive and not very large, we should have a very    *</span>
<span class="cm">     *  good approximation for sqrt(x). Heron&#39;s method will still work for    *</span>
<span class="cm">     *  very large x, but we must increase MAXIMUM_NUMBER_OF_ITERATIONS.      */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of heronsMethod.                                                      */</span>

<span class="cm">/*  Test out our function, compute sqrt(2) and print it to the screen.        */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">SQRT_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">heronsMethod</span><span class="p">(</span><span class="nx">X</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;sqrt(2) = &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">SQRT_2</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mf">16</span><span class="p">));</span>

<span class="cm">/*  We can run this outside of a browser by using the cross-platform runtime  *</span>
<span class="cm"> *  environment node.js:                                                      *</span>
<span class="cm"> *      https://nodejs.org/en                                                 *</span>
<span class="cm"> *  After installing, type:                                                   *</span>
<span class="cm"> *      node herons_method.js                                                 *</span>
<span class="cm"> *  This will output:                                                         *</span>
<span class="cm"> *      sqrt(2) = 1.4142135623730949                                          *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       */</span>
</pre></div>

<h2 id="kotlin">Kotlin<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/05/18                                                        *</span>
<span class="cm"> ******************************************************************************/</span>
<span class="k">import</span><span class="w"> </span><span class="nn">kotlin.math.abs</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> *  Function:                                                                 *</span>
<span class="cm"> *      heronsMethod                                                          *</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Computes square roots of positive real numbers using Heron&#39;s method.  *</span>
<span class="cm"> *  Arguments:                                                                *</span>
<span class="cm"> *      x (Double):                                                           *</span>
<span class="cm"> *          A positive real number, the input to the square root function.    *</span>
<span class="cm"> *  Output:                                                                   *</span>
<span class="cm"> *      sqrt_x (Double):                                                      *</span>
<span class="cm"> *          The square root of the input.                                     *</span>
<span class="cm"> ******************************************************************************/</span>
<span class="kd">fun</span><span class="w"> </span><span class="nf">heronsMethod</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="p">):</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      */</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">maximumNumberOfIterations</span><span class="p">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">16</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is 4x double precision epsilon.       */</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">epsilon</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">8.881784197001252E-16</span>

<span class="w">    </span><span class="cm">/*  Set the initial guess to the input. Provided x is positive, Heron&#39;s   *</span>
<span class="cm">     *  method will indeed converge.                                          */</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nv">approximateRoot</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>

<span class="w">    </span><span class="cm">/*  Iteratively loop through and obtain better approximations for sqrt(x).*/</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">..</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If we are within epsilon of the correct value we may break out of *</span>
<span class="cm">         *  this for-loop. Use the absolute value function to check.          */</span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="nv">error</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximateRoot</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">approximateRoot</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span>

<span class="w">        </span><span class="cm">/*  Apply Heron&#39;s method to get a better approximation for the root.  */</span>
<span class="w">        </span><span class="n">approximateRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximateRoot</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">approximateRoot</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  As long as x is positive and not very large, we should have a very    *</span>
<span class="cm">     *  good approximation for sqrt(x). Heron&#39;s method will still work for    *</span>
<span class="cm">     *  very large x, but we must increase maximum_number_of_iterations.      */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">approximateRoot</span>
<span class="p">}</span>
<span class="cm">/*  End of heronsMethod.                                                      */</span>

<span class="cm">/*  Test out our function, compute the square root of 2.                      */</span>
<span class="kd">fun</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2.0</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">sqrt_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heronsMethod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;sqrt(</span><span class="si">$</span><span class="n">x</span><span class="s">) = </span><span class="si">$</span><span class="n">sqrt_x</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="cm">/*  We can run this using the Kotlin compiler, kotlinc:                       *</span>
<span class="cm"> *      https://github.com/JetBrains/kotlin/releases                          *</span>
<span class="cm"> *  See also:                                                                 *</span>
<span class="cm"> *      https://kotlinlang.org/                                               *</span>
<span class="cm"> *  You will also need to install Java OpenJDK. Once done, type:              *</span>
<span class="cm"> *      kotlinc herons_method.kt -d herons_method.jar                         *</span>
<span class="cm"> *      java -jar herons_method.jar                                           *</span>
<span class="cm"> *  This will output:                                                         *</span>
<span class="cm"> *      sqrt(2.0) = 1.414213562373095                                         *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On Windows you can install kotlinc-native from the same link. Type:       *</span>
<span class="cm"> *      kotlinc-native herons_method.kt -output main.exe                      *</span>
<span class="cm"> *      main.exe                                                              *</span>
<span class="cm"> *  This produces the same output.                                            */</span>
</pre></div>

<h2 id="matlab">MATLAB<br /></h2>
<div class="highlight"><pre><span></span><span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%                                   LICENSE                                    %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   This file is part of mitx_mathematics_programming_examples.                %</span>
<span class="c">%                                                                              %</span>
<span class="c">%   mitx_mathematics_programming_examples is free software: you can            %</span>
<span class="c">%   redistribute it and/or modify it under the terms of the GNU General Public %</span>
<span class="c">%   License as published by the Free Software Foundation, either version 3 of  %</span>
<span class="c">%   the License, or (at your option) any later version.                        %</span>
<span class="c">%                                                                              %</span>
<span class="c">%   mitx_mathematics_programming_examples is distributed in the hope that it   %</span>
<span class="c">%   will be useful, but WITHOUT ANY WARRANTY; without even the implied         %</span>
<span class="c">%   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  %</span>
<span class="c">%   GNU General Public License for more details.                               %</span>
<span class="c">%                                                                              %</span>
<span class="c">%   You should have received a copy of the GNU General Public License          %</span>
<span class="c">%   along with mitx_mathematics_programming_examples.  If not, see             %</span>
<span class="c">%   &lt;https://www.gnu.org/licenses/&gt;.                                           %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   Purpose:                                                                   %</span>
<span class="c">%       Calculates square roots using Heron&#39;s method.                          %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   Author:     Ryan Maguire                                                   %</span>
<span class="c">%   Date:       March 9, 2025.                                                 %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   Function:                                                                  %</span>
<span class="c">%       herons_method                                                          %</span>
<span class="c">%   Purpose:                                                                   %</span>
<span class="c">%       Computes square roots of positive real numbers using Heron&#39;s method.   %</span>
<span class="c">%   Arguments:                                                                 %</span>
<span class="c">%       x (real):                                                              %</span>
<span class="c">%           A positive real number, the input to the square root function.     %</span>
<span class="c">%   Output:                                                                    %</span>
<span class="c">%       sqrt_x (real):                                                         %</span>
<span class="c">%           The square root of the input.                                      %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="k">function</span><span class="w"> </span>approximate_root<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">herons_method</span><span class="p">(</span>x<span class="p">)</span>

<span class="w">    </span><span class="c">% Heron&#39;s method is iterative and the convergence is quadratic. This</span>
<span class="w">    </span><span class="c">% means that if a_{n} has N correct decimals, then a_{n+1} will have</span>
<span class="w">    </span><span class="c">% 2N correct decimals. A standard 64-bit double can fit about 16</span>
<span class="w">    </span><span class="c">% decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).</span>
<span class="w">    </span><span class="c">% Because of this we may exit the function after a few iterations.</span>
<span class="w">    </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="w">    </span><span class="c">% The maximum allowed error. This is 4x double precision epsilon.</span>
<span class="w">    </span><span class="n">epsilon</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span><span class="p">;</span>

<span class="w">    </span><span class="c">% Set the initial guess to the input. Provided x is positive, Heron&#39;s</span>
<span class="w">    </span><span class="c">% method will indeed converge.</span>
<span class="w">    </span><span class="n">approximate_root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="c">% Iteratively apply Heron&#39;s method.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">maximum_number_of_iterations</span>

<span class="w">        </span><span class="c">% If the error is small we can break out of this for-loop. Check.</span>
<span class="w">        </span><span class="nb">error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">abs</span><span class="p">(</span><span class="nb">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c">% Otherwise improve the approximation using Heron&#39;s method.</span>
<span class="w">        </span><span class="n">approximate_root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximate_root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">);</span>

<span class="w">    </span><span class="k">end</span>

<span class="k">end</span>

<span class="c">% Test out our implementation by computing the square root of 2.</span>
<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="n">sqrt_x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;sqrt(%.1f) = %.16f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt_x</span><span class="p">);</span>

<span class="c">% We can run this using GNU Octave, a free and open source</span>
<span class="c">% alternative to MATLAB:</span>
<span class="c">%   https://octave.org/download</span>
<span class="c">% Once installed, type:</span>
<span class="c">%   octave herons_method.matlab.m</span>
<span class="c">% This outputs:</span>
<span class="c">%   sqrt(2.0) = 1.4142135623730949</span>
<span class="c">% This has a relative error of 1.570092458683775E-16.</span>
</pre></div>

<h2 id="objective-c">Objective-C<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/08                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  stdio.h provides the &quot;printf&quot; function, used for printing text.           */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cm">/*  Floating-point absolute value function, fabs, provided here.              */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>

<span class="cm">/*  NSObject, the base class for all Objective-C classes, found here.         */</span>
<span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="cm">/*  Simple class with a single method, square root via Heron&#39;s method.        */</span>
<span class="k">@interface</span> <span class="nc">Heron</span>: <span class="bp">NSObject</span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">sqrt</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
<span class="k">@end</span>

<span class="cm">/*  Class providing an implementation of sqrt using Heron&#39;s method.           */</span>
<span class="k">@implementation</span> <span class="nc">Heron</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      *</span>
<span class="cm">     *                                                                        *</span>
<span class="cm">     *  Note:                                                                 *</span>
<span class="cm">     *      We are declaring the following integer as &quot;unsigned&quot; meaning      *</span>
<span class="cm">     *      non-negative. The &quot;U&quot; after the number is the suffix for unsigned *</span>
<span class="cm">     *      constants in Objective-C. It simply means unsigned.               */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is 4x double precision epsilon.       */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">8.881784197001252E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Computes square roots of positive real numbers via Heron&#39;s method.    */</span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">sqrt</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">x</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Variable for keeping track of the number of iterations.           */</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Set the initial guess to the input. Provided x is positive,       *</span>
<span class="cm">         *  Heron&#39;s method will indeed converge.                              */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Iteratively loop through and obtain better approximations.        */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  If we are within epsilon of the correct value we may break    *</span>
<span class="cm">             *  out of this for-loop. Check the relative error.               */</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Apply Heron&#39;s method to get a better approximation.           */</span>
<span class="w">            </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximate_root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="o">/</span><span class="n">approximate_root</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  As long as x is positive and not very large, we should have a     *</span>
<span class="cm">         *  very good approximation for sqrt(x). Heron&#39;s method will still    *</span>
<span class="cm">         *  work for very large x, but we must increase the value of          *</span>
<span class="cm">         *  maximum_number_of_iterations.                                     */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/*  End of sqrt.                                                          */</span>
<span class="k">@end</span>
<span class="cm">/*  End of Heron definition.                                                  */</span>

<span class="cm">/*  Main routine used for testing our implementation of Heron&#39;s method.       */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  The input to Heron&#39;s method, the value we want to compute the square  *</span>
<span class="cm">     *  root of.                                                              */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Calculate the square root and print it to the screen. If we have      *</span>
<span class="cm">     *  written things correctly, we should get 1.414..., which is sqrt(2).   */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sqrt_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">Heron</span><span class="w"> </span><span class="n">sqrt</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">];</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sqrt(%.1f) = %.16f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt_x</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  We can run this by installing GCC, which contains an Objective-C          *</span>
<span class="cm"> *  compiler, and GNUstep, which provides the Foundation framework:           *</span>
<span class="cm"> *      https://www.gnustep.org/                                              *</span>
<span class="cm"> *  Once installed, type:                                                     *</span>
<span class="cm"> *      gcc `gnustep-config --objc-flags` herons_method.objc.m -o main \      *</span>
<span class="cm"> *          `gnustep-config --objc-libs` `gnustep-config --base-libs`         *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  This will output the following:                                           *</span>
<span class="cm"> *      sqrt(2.0) = 1.4142135623730949                                        *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On Windows this is a bit more complicated. Setup MSYS2 and MinGW-w64:     *</span>
<span class="cm"> *      https://www.msys2.org/                                                *</span>
<span class="cm"> *      https://www.mingw-w64.org/getting-started/msys2/                      *</span>
<span class="cm"> *  Then follow the steps to install GCC and GNUstep:                         *</span>
<span class="cm"> *      https://mediawiki.gnustep.org/index.php/Installation_MSYS2            *</span>
<span class="cm"> *  Once installed, make sure the GNUstep Tools directory is in your DLL path *</span>
<span class="cm"> *  and then type:                                                            *</span>
<span class="cm"> *      gcc -IC:\msys64\mingw64\Local\Library\Headers   ^                     *</span>
<span class="cm"> *          -LC:\msys64\mingw64\Local\Library\Libraries ^                     *</span>
<span class="cm"> *          herons_method.objc.m -o main.exe -lobjc -lgnustep-base            *</span>
<span class="cm"> *      main.exe                                                              *</span>
<span class="cm"> *  This will produce the same result. Windows users can also try using the   *</span>
<span class="cm"> *  GNUstep Windows MSVC Toolschain:                                          *</span>
<span class="cm"> *      https://github.com/gnustep/tools-windows-msvc                         *</span>
<span class="cm"> *  Once installed you can compile Objective-C code from the command line.    */</span>
</pre></div>

<h2 id="pascal">Pascal<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">(******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General Public*</span>
<span class="cm"> *  License as published by the Free Software Foundation, either version 3 of *</span>
<span class="cm"> *  the License, or (at your option) any later version.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that it  *</span>
<span class="cm"> *  will be useful but WITHOUT ANY WARRANTY; without even the implied warranty*</span>
<span class="cm"> *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *</span>
<span class="cm"> *  GNU General Public License for more details.                              *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples.  If not, see            *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/09                                                        *</span>
<span class="cm"> ******************************************************************************)</span>
<span class="k">PROGRAM</span><span class="w"> </span><span class="n">Heron</span><span class="o">;</span>

<span class="cm">(*  We define two constants: The allowed tolerance (or epsilon value),        *</span>
<span class="cm"> *  and the maximum number of iterations we allow for Heron&#39;s method.         *)</span>
<span class="k">CONST</span>

<span class="w">    </span><span class="cm">(*  Heron&#39;s method is iterative. The convergence is quadratic,            *</span>
<span class="cm">     *  meaning the number of accurate decimals doubles with each             *</span>
<span class="cm">     *  iteration. Because of this we can stop after a few steps.             *)</span>
<span class="w">    </span><span class="n">MaximumNumberOfIterations</span><span class="o">:</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Maximum allowed error. This is double precision epsilon.              *)</span>
<span class="w">    </span><span class="n">Epsilon</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  The input value we will compute the square root of.                   *)</span>
<span class="w">    </span><span class="n">Value</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">;</span>

<span class="k">VAR</span>
<span class="w">    </span><span class="cm">(*  Variable for the square root of our input.                            *)</span>
<span class="w">    </span><span class="n">SqrtValue</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="cm">(******************************************************************************</span>
<span class="cm"> *  Function:                                                                 *</span>
<span class="cm"> *      HeronsMethod                                                          *</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Computes square roots using Heron&#39;s method.                           *</span>
<span class="cm"> *  Arguments:                                                                *</span>
<span class="cm"> *      X (Real):                                                             *</span>
<span class="cm"> *          A positive real number.                                           *</span>
<span class="cm"> *  OUTPUT:                                                                   *</span>
<span class="cm"> *      SqrtX (Real):                                                         *</span>
<span class="cm"> *          The square root of X.                                             *</span>
<span class="cm"> ******************************************************************************)</span>
<span class="k">Function</span><span class="w"> </span><span class="nf">HeronsMethod</span><span class="p">(</span><span class="k">Const</span><span class="w"> </span><span class="n">X</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="k">VAR</span>
<span class="w">    </span><span class="n">Error</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>
<span class="w">    </span><span class="n">Iters</span><span class="o">:</span><span class="w"> </span><span class="kt">Integer</span><span class="o">;</span>

<span class="k">BEGIN</span>

<span class="w">    </span><span class="cm">(* Heron&#39;s method needs a starting value. Pick the input.                 *)</span>
<span class="w">    </span><span class="n">HeronsMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">X</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Iteratively perform Heron&#39;s method.                                   *)</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="n">Iters</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="n">MaximumNumberOfIterations</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">DO</span>
<span class="w">    </span><span class="k">BEGIN</span>

<span class="w">        </span><span class="cm">(*  If the error is small we can break out of this loop.              *)</span>
<span class="w">        </span><span class="n">Error</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">HeronsMethod</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">HeronsMethod</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">X</span><span class="o">;</span>

<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">Error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Epsilon</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="k">BREAK</span><span class="o">;</span>

<span class="w">        </span><span class="cm">(*  Otherwise, improve our approximation using Heron&#39;s method.        *)</span>
<span class="w">        </span><span class="n">HeronsMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">HeronsMethod</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">HeronsMethod</span><span class="p">)</span><span class="o">;</span>
<span class="w">    </span><span class="k">END</span><span class="o">;</span>
<span class="k">END</span><span class="o">;</span>

<span class="cm">(*  Program for testing our implementation of Heron&#39;s method.                 *)</span>
<span class="k">BEGIN</span>

<span class="w">    </span><span class="cm">(*  Compute the square root using Heron&#39;s method and print the result.    *)</span>
<span class="w">    </span><span class="n">SqrtValue</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">HeronsMethod</span><span class="p">(</span><span class="n">Value</span><span class="p">)</span><span class="o">;</span>
<span class="w">    </span><span class="nb">WriteLn</span><span class="p">(</span><span class="s">&#39;sqrt(&#39;</span><span class="o">,</span><span class="w"> </span><span class="n">Value</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s">&#39;) = &#39;</span><span class="o">,</span><span class="w"> </span><span class="n">SqrtValue</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">16</span><span class="p">)</span><span class="o">;</span>

<span class="k">END</span><span class="o">.</span>

<span class="cm">(*  We can compile this using the Free Pascal Compiler (fpc):                 *</span>
<span class="cm"> *      https://www.freepascal.org/                                           *</span>
<span class="cm"> *  Once installed, on GNU, Linux, FreeBSD, macOS, etc., this can be run by:  *</span>
<span class="cm"> *      fpc herons_method.pas -omain                                          *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  This outputs:                                                             *</span>
<span class="cm"> *      sqrt(2.0) = 1.4142135623730949                                        *</span>
<span class="cm"> *  The relative error is 1.570092458683775E-16.                              *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On Windows, type:                                                         *</span>
<span class="cm"> *      fpc herons_method.pas -omain.exe                                      *</span>
<span class="cm"> *      main.exe                                                              *</span>
<span class="cm"> *  This produces the same output.                                            *)</span>
</pre></div>

<h2 id="idl">IDL<br /></h2>
<div class="highlight"><pre><span></span><span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="p">;</span>                                   <span class="nv">LICENSE</span>                                    <span class="p">;</span>
<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="p">;</span>   <span class="nv">This</span> <span class="s s-Atom">file</span> <span class="o">is</span> <span class="s s-Atom">part</span> <span class="s s-Atom">of</span> <span class="s s-Atom">mitx_mathematics_programming_examples</span><span class="p">.</span>                <span class="p">;</span>
<span class="p">;</span>                                                                              <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">mitx_mathematics_programming_examples</span> <span class="o">is</span> <span class="s s-Atom">free</span> <span class="nn">software</span><span class="p">:</span> <span class="s s-Atom">you</span> <span class="s s-Atom">can</span>            <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">redistribute</span> <span class="s s-Atom">it</span> <span class="s s-Atom">and</span><span class="o">/</span><span class="s s-Atom">or</span> <span class="s s-Atom">modify</span> <span class="s s-Atom">it</span> <span class="s s-Atom">under</span> <span class="s s-Atom">the</span> <span class="s s-Atom">terms</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span> <span class="nv">GNU</span> <span class="nv">General</span> <span class="nv">Public</span> <span class="p">;</span>
<span class="p">;</span>   <span class="nv">License</span> <span class="s s-Atom">as</span> <span class="s s-Atom">published</span> <span class="s s-Atom">by</span> <span class="s s-Atom">the</span> <span class="nv">Free</span> <span class="nv">Software</span> <span class="nv">Foundation</span><span class="p">,</span> <span class="s s-Atom">either</span> <span class="s s-Atom">version</span> <span class="mi">3</span> <span class="s s-Atom">of</span>  <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">the</span> <span class="nv">License</span><span class="p">,</span> <span class="nf">or</span> <span class="p">(</span><span class="s s-Atom">at</span> <span class="s s-Atom">your</span> <span class="s s-Atom">option</span><span class="p">)</span> <span class="s s-Atom">any</span> <span class="s s-Atom">later</span> <span class="s s-Atom">version</span><span class="p">.</span>                        <span class="p">;</span>
<span class="p">;</span>                                                                              <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">mitx_mathematics_programming_examples</span> <span class="o">is</span> <span class="s s-Atom">distributed</span> <span class="s s-Atom">in</span> <span class="s s-Atom">the</span> <span class="s s-Atom">hope</span> <span class="s s-Atom">that</span> <span class="s s-Atom">it</span>   <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">will</span> <span class="s s-Atom">be</span> <span class="s s-Atom">useful</span> <span class="s s-Atom">but</span> <span class="nv">WITHOUT</span> <span class="nv">ANY</span> <span class="nv">WARRANTY</span><span class="p">;</span> <span class="s s-Atom">without</span> <span class="s s-Atom">even</span> <span class="s s-Atom">the</span> <span class="s s-Atom">implied</span> <span class="s s-Atom">warranty</span> <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">of</span> <span class="nv">MERCHANTABILITY</span> <span class="s s-Atom">or</span> <span class="nv">FITNESS</span> <span class="nv">FOR</span> <span class="nv">A</span> <span class="nv">PARTICULAR</span> <span class="nv">PURPOSE</span><span class="p">.</span>  <span class="nv">See</span> <span class="s s-Atom">the</span>           <span class="p">;</span>
<span class="p">;</span>   <span class="nv">GNU</span> <span class="nv">General</span> <span class="nv">Public</span> <span class="nv">License</span> <span class="s s-Atom">for</span> <span class="s s-Atom">more</span> <span class="s s-Atom">details</span><span class="p">.</span>                               <span class="p">;</span>
<span class="p">;</span>                                                                              <span class="p">;</span>
<span class="p">;</span>   <span class="nv">You</span> <span class="s s-Atom">should</span> <span class="s s-Atom">have</span> <span class="s s-Atom">received</span> <span class="s s-Atom">a</span> <span class="s s-Atom">copy</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span> <span class="nv">GNU</span> <span class="nv">General</span> <span class="nv">Public</span> <span class="nv">License</span>          <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">along</span> <span class="s s-Atom">with</span> <span class="s s-Atom">mitx_mathematics_programming_examples</span><span class="p">.</span>  <span class="nv">If</span> <span class="o">not</span><span class="p">,</span> <span class="s s-Atom">see</span>             <span class="p">;</span>
<span class="p">;</span>   <span class="o">&lt;</span><span class="nn">https</span><span class="p">:</span><span class="o">//</span><span class="s s-Atom">www</span><span class="p">.</span><span class="s s-Atom">gnu</span><span class="p">.</span><span class="s s-Atom">org</span><span class="o">/</span><span class="s s-Atom">licenses/&gt;.</span>                                           <span class="p">;</span>
<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="p">;</span>   <span class="nv">Purpose</span><span class="s s-Atom">:</span>                                                                   <span class="p">;</span>
<span class="p">;</span>       <span class="nv">Calculates</span> <span class="s s-Atom">roots</span> <span class="s s-Atom">using</span> <span class="s s-Atom">the</span> <span class="s s-Atom">bisection</span> <span class="s s-Atom">method</span><span class="p">.</span>                           <span class="p">;</span>
<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="p">;</span>   <span class="nv">Author</span><span class="s s-Atom">:</span> <span class="nv">Ryan</span> <span class="nv">Maguire</span>                                                       <span class="p">;</span>
<span class="p">;</span>   <span class="nv">Date</span><span class="s s-Atom">:</span>   <span class="mi">2025</span><span class="o">/</span><span class="mi">05</span><span class="o">/</span><span class="mi">22</span>                                                         <span class="p">;</span>
<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="nv">FUNCTION</span> <span class="nv">HERON</span><span class="p">,</span> <span class="nv">X</span>

    <span class="p">;</span> <span class="nv">Tells</span> <span class="s s-Atom">the</span> <span class="s s-Atom">compiler</span> <span class="s s-Atom">that</span> <span class="s s-Atom">integers</span> <span class="s s-Atom">should</span> <span class="s s-Atom">be</span> <span class="mi">32</span> <span class="s s-Atom">bits</span><span class="p">,</span> <span class="o">not</span> <span class="mf">16.</span>
    <span class="nv">COMPILE_OPT</span> <span class="nv">IDL2</span>

    <span class="p">;</span> <span class="nv">Error</span> <span class="s s-Atom">checking</span> <span class="s s-Atom">code</span><span class="p">.</span>
    <span class="nv">ON_ERROR</span><span class="p">,</span> <span class="mi">2</span>

    <span class="p">;</span> <span class="nv">Heron</span><span class="s s-Atom">&#39;s method is iterative. The convergence is quadratic, meaning the</span>
<span class="s s-Atom">    ; number of accurate decimals doubles with each iteration. Because of this</span>
<span class="s s-Atom">    ; we can halt the algorithm after a few steps.</span>
<span class="s s-Atom">    MAXIMUM_NUMBER_OF_ITERATIONS = 16</span>

<span class="s s-Atom">    ; Maximum allowed error. This is double precision epsilon.</span>
<span class="s s-Atom">    EPSILON = 2.220446049250313E-16</span>

<span class="s s-Atom">    ; Variable used for Heron&#39;s</span> <span class="s s-Atom">approximation</span><span class="p">.</span> <span class="nv">We</span> <span class="s s-Atom">will</span> <span class="s s-Atom">iteratively</span> <span class="s s-Atom">update</span>
    <span class="p">;</span> <span class="s s-Atom">this</span> <span class="s s-Atom">value</span> <span class="s s-Atom">with</span> <span class="s s-Atom">better</span> <span class="s s-Atom">approximations</span> <span class="s s-Atom">using</span> <span class="nv">Heron</span><span class="s s-Atom">&#39;s method</span>
<span class="s s-Atom">    APPROXIMATE_ROOT = x</span>

<span class="s s-Atom">    ; Iteratively perform Heron&#39;s</span> <span class="s s-Atom">method</span><span class="p">.</span>
    <span class="nv">FOR</span> <span class="nv">ITERS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">MAXIMUM_NUMBER_OF_ITERATIONS</span> <span class="nv">DO</span> <span class="nv">BEGIN</span>

        <span class="p">;</span> <span class="nv">If</span> <span class="s s-Atom">the</span> <span class="s s-Atom">error</span> <span class="o">is</span> <span class="s s-Atom">small</span> <span class="s s-Atom">we</span> <span class="s s-Atom">can</span> <span class="s s-Atom">break</span> <span class="s s-Atom">out</span> <span class="s s-Atom">of</span> <span class="s s-Atom">this</span> <span class="s s-Atom">loop</span><span class="p">.</span>
        <span class="nv">ERROR</span> <span class="o">=</span> <span class="p">(</span><span class="nv">X</span> <span class="o">-</span> <span class="nv">APPROXIMATE_ROOT</span> <span class="o">*</span> <span class="nv">APPROXIMATE_ROOT</span><span class="p">)</span> <span class="o">/</span> <span class="nv">X</span>

        <span class="nv">IF</span> <span class="p">(</span><span class="nv">ABS</span><span class="p">(</span><span class="nv">ERROR</span><span class="p">)</span> <span class="nv">LE</span> <span class="nv">EPSILON</span><span class="p">)</span> <span class="nv">THEN</span> <span class="nv">BREAK</span>

        <span class="p">;</span> <span class="nv">Otherwise</span><span class="p">,</span> <span class="s s-Atom">improve</span> <span class="s s-Atom">our</span> <span class="s s-Atom">approximation</span> <span class="s s-Atom">using</span> <span class="nv">Heron</span><span class="s s-Atom">&#39;s method.</span>
<span class="s s-Atom">        APPROXIMATE_ROOT = 0.5 * (APPROXIMATE_ROOT + X / APPROXIMATE_ROOT)</span>

<span class="s s-Atom">    END</span>

<span class="s s-Atom">    ; If x is positive and not too big, APPROXIMATE_ROOT should have a</span>
<span class="s s-Atom">    ; very accurate approximation to sqrt(x). Heron&#39;s</span> <span class="s s-Atom">method</span> <span class="s s-Atom">works</span> <span class="s s-Atom">for</span>
    <span class="p">;</span> <span class="s s-Atom">large</span> <span class="s s-Atom">inputs</span> <span class="s s-Atom">as</span> <span class="s s-Atom">well</span><span class="p">,</span> <span class="s s-Atom">but</span> <span class="s s-Atom">we</span> <span class="s s-Atom">need</span> <span class="s s-Atom">to</span> <span class="s s-Atom">increase</span> <span class="s s-Atom">the</span> <span class="s s-Atom">value</span> <span class="s s-Atom">of</span>
    <span class="p">;</span> <span class="nv">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="p">.</span>
    <span class="nv">RETURN</span><span class="p">,</span> <span class="nv">APPROXIMATE_ROOT</span>

<span class="nv">END</span>

<span class="p">;</span> <span class="nv">Program</span> <span class="s s-Atom">for</span> <span class="s s-Atom">testing</span> <span class="s s-Atom">our</span> <span class="s s-Atom">implementation</span> <span class="s s-Atom">of</span> <span class="nv">Heron</span><span class="s s-Atom">&#39;s method.</span>
<span class="s s-Atom">PRO MAIN</span>

<span class="s s-Atom">    COMPILE_OPT IDL2</span>

<span class="s s-Atom">    ; The input for the method. We&#39;ll</span> <span class="s s-Atom">compute</span> <span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span>
    <span class="nv">X</span> <span class="o">=</span> <span class="nv">DOUBLE</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>

    <span class="p">;</span> <span class="nv">Run</span> <span class="s s-Atom">the</span> <span class="s s-Atom">routine</span><span class="p">,</span> <span class="s s-Atom">computing</span> <span class="nf">sqrt</span><span class="p">(</span><span class="s s-Atom">x</span><span class="p">),</span> <span class="s s-Atom">and</span> <span class="s s-Atom">print</span> <span class="s s-Atom">the</span> <span class="s s-Atom">result</span><span class="p">.</span>
    <span class="nv">SQRT_2</span> <span class="o">=</span> <span class="nv">HERON</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span>
    <span class="nv">PRINT</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">SQRT_2</span><span class="p">,</span> <span class="nv">FORMAT</span> <span class="o">=</span> <span class="s s-Atom">&#39;SQRT(%3.1f) = %18.16f&#39;</span>

<span class="nv">END</span>

<span class="p">;</span> <span class="nv">We</span> <span class="s s-Atom">can</span> <span class="s s-Atom">run</span> <span class="s s-Atom">this</span> <span class="s s-Atom">by</span> <span class="s s-Atom">installing</span> <span class="s s-Atom">the</span> <span class="nv">GNU</span> <span class="nv">Data</span> <span class="nv">Language</span> <span class="p">(</span><span class="nv">GDL</span><span class="p">),</span> <span class="s s-Atom">which</span> <span class="o">is</span>
<span class="p">;</span> <span class="s s-Atom">a</span> <span class="s s-Atom">free</span> <span class="s s-Atom">and</span> <span class="s s-Atom">open</span> <span class="s s-Atom">source</span> <span class="s s-Atom">alternative</span> <span class="s s-Atom">to</span> <span class="nv">IDL</span><span class="s s-Atom">:</span>
<span class="p">;</span>   <span class="nn">https</span><span class="p">:</span><span class="o">//</span><span class="s s-Atom">gnudatalanguage</span><span class="p">.</span><span class="s s-Atom">github</span><span class="p">.</span><span class="s s-Atom">io</span><span class="o">/</span>
<span class="p">;</span> <span class="nv">Once</span> <span class="s s-Atom">installed</span><span class="p">,</span> <span class="s s-Atom">start</span> <span class="nv">GDL</span> <span class="s s-Atom">by</span> <span class="s s-Atom">typing</span> <span class="s s-Atom">gdl</span><span class="p">.</span> <span class="nv">Once</span> <span class="s s-Atom">running</span><span class="p">,</span> <span class="nn">type</span><span class="p">:</span>
<span class="p">;</span>   <span class="nv">GDL</span><span class="o">&gt;</span> <span class="p">.</span><span class="s s-Atom">compile</span> <span class="s s-Atom">herons_method</span><span class="p">.</span><span class="s s-Atom">pro</span>
<span class="p">;</span>   <span class="nv">GDL</span><span class="o">&gt;</span> <span class="s s-Atom">main</span>
<span class="p">;</span> <span class="nv">This</span> <span class="s s-Atom">will</span> <span class="s s-Atom">produce</span> <span class="s s-Atom">the</span> <span class="s s-Atom">following</span> <span class="nn">output</span><span class="p">:</span>
<span class="p">;</span>   <span class="nv">SQRT</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.4142135623730949</span>
<span class="p">;</span> <span class="nv">The</span> <span class="s s-Atom">relative</span> <span class="s s-Atom">error</span> <span class="o">is</span> <span class="mf">1.570092458683775E-16</span><span class="p">.</span>
</pre></div>

<h2 id="python">Python<br /></h2>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">################################################################################</span>
<span class="sd">#                                   LICENSE                                    #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="sd">#   redistribute it and/or modify it under the terms of the GNU General        #</span>
<span class="sd">#   Public License as published by the Free Software Foundation, either        #</span>
<span class="sd">#   version 3 of the License, or (at your option) any later version.           #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is distributed in the hope that      #</span>
<span class="sd">#   it will be useful but WITHOUT ANY WARRANTY; without even the implied       #</span>
<span class="sd">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.           #</span>
<span class="sd">#   See the GNU General Public License for more details.                       #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   You should have received a copy of the GNU General Public License          #</span>
<span class="sd">#   along with mitx_mathematics_programming_examples. If not, see              #</span>
<span class="sd">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Purpose:                                                                   #</span>
<span class="sd">#       Calculates square roots using Heron&#39;s method.                          #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Author: Ryan Maguire                                                       #</span>
<span class="sd">#   Date:   2025/03/08                                                         #</span>
<span class="sd">################################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Pylint doesn&#39;t like &quot;x&quot; as a variable name. Disable this warning.</span>
<span class="c1"># pylint: disable = invalid-name</span>

<span class="c1"># Computes the square root of a positive real number via Heron&#39;s method.</span>
<span class="k">def</span> <span class="nf">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function:</span>
<span class="sd">            herons_method</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Applies Heron&#39;s method to a positive real number, returning</span>
<span class="sd">            the square root of it.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            x (float):</span>
<span class="sd">                A positive real number.</span>
<span class="sd">        Output:</span>
<span class="sd">            sqrt_x (float):</span>
<span class="sd">                The square root of x.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Heron&#39;s method only works for strictly positive real numbers.</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input must be a positive real number.&quot;</span><span class="p">)</span>

    <span class="c1"># Heron&#39;s method is iterative and the convergence is quadratic. This</span>
    <span class="c1"># means that if a_{n} has N correct decimals, then a_{n+1} will have</span>
    <span class="c1"># 2N correct decimals. A standard 64-bit double can fit about 16</span>
    <span class="c1"># decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).</span>
    <span class="c1"># Because of this we may exit the function after a few iterations.</span>
    <span class="n">maximum_number_of_iterations</span> <span class="o">=</span> <span class="mi">16</span>

    <span class="c1"># The maximum allowed error. This is double precision epsilon.</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">2.220446049250313E-16</span>

    <span class="c1"># Set the initial guess to the input. Provided x is positive, Heron&#39;s</span>
    <span class="c1"># method will indeed converge.</span>
    <span class="n">approximate_root</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># Iteratively loop through and obtain better approximations for sqrt(x).</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maximum_number_of_iterations</span><span class="p">):</span>

        <span class="c1"># If we are within epsilon of the correct value we may break out of</span>
        <span class="c1"># this for-loop. Use the absolute value function to check.</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">approximate_root</span> <span class="o">*</span> <span class="n">approximate_root</span><span class="p">)</span> <span class="o">/</span> <span class="n">x</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">epsilon</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Apply Heron&#39;s method to get a better approximation for the root.</span>
        <span class="n">approximate_root</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">approximate_root</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">approximate_root</span><span class="p">)</span>

    <span class="c1"># As long as x is positive and not very large, we should have a very</span>
    <span class="c1"># good approximation for sqrt(x). Heron&#39;s method will still work for</span>
    <span class="c1"># very large x, but we must increase maximum_number_of_iterations.</span>
    <span class="k">return</span> <span class="n">approximate_root</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main routine for testing our implementation of Heron&#39;s method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">sqrt_x</span> <span class="o">=</span> <span class="n">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sqrt(</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">sqrt_x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>

<span class="c1"># We can run this using the standard Python implementation, C-Python:</span>
<span class="c1">#   https://www.python.org/downloads/</span>
<span class="c1"># Once installed, run:</span>
<span class="c1">#   python3 herons_method.py</span>
<span class="c1"># Depending on your platform you may need to replace &quot;python3&quot; with &quot;python&quot;</span>
<span class="c1"># or &quot;py&quot; or &quot;py3&quot;. This will output:</span>
<span class="c1">#   sqrt(2.0) = 1.414213562373095</span>
<span class="c1"># This has relative error 1.570092458683775E-16.</span>
</pre></div>

<h2 id="r">R<br /></h2>
<div class="highlight"><pre><span></span><span class="c">################################################################################</span>
<span class="c">#                                   LICENSE                                    #</span>
<span class="c">################################################################################</span>
<span class="c">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="c">#   redistribute it and/or modify it under the terms of the GNU General        #</span>
<span class="c">#   Public License as published by the Free Software Foundation, either        #</span>
<span class="c">#   version 3 of the License, or (at your option) any later version.           #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is distributed in the hope that      #</span>
<span class="c">#   it will be useful but WITHOUT ANY WARRANTY; without even the implied       #</span>
<span class="c">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.           #</span>
<span class="c">#   See the GNU General Public License for more details.                       #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   You should have received a copy of the GNU General Public License          #</span>
<span class="c">#   along with mitx_mathematics_programming_examples. If not, see              #</span>
<span class="c">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="c">################################################################################</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Calculates square roots using Heron&#39;s method.                          #</span>
<span class="c">################################################################################</span>
<span class="c">#   Author: Ryan Maguire                                                       #</span>
<span class="c">#   Date:   2025/05/18                                                         #</span>
<span class="c">################################################################################</span>

<span class="c"># Computes the square root of a positive real number via Heron&#39;s method.</span>
<span class="c">herons_method &lt;- function(x) {</span>

<span class="c">    # Heron&#39;s method is iterative and the convergence is quadratic. This</span>
<span class="c">    # means that if a_{n} has N correct decimals, then a_{n+1} will have</span>
<span class="c">    # 2N correct decimals. A standard 64-bit double can fit about 16</span>
<span class="c">    # decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).</span>
<span class="c">    # Because of this we may exit the function after a few iterations.</span>
<span class="c">    maximum_number_of_iterations &lt;- 16</span>

<span class="c">    # The maximum allowed error. This is double precision epsilon.</span>
<span class="c">    epsilon &lt;- 2.220446049250313E-16</span>

<span class="c">    # Set the initial guess to the input. Provided x is positive, Heron&#39;s</span>
<span class="c">    # method will indeed converge.</span>
<span class="c">    approximate_root &lt;- x</span>

<span class="c">    # Iteratively loop through and obtain better approximations for sqrt(x).</span>
<span class="c">    for (iters in 1:maximum_number_of_iterations) {</span>

<span class="c">        # If we are within epsilon of the correct value we may break out of</span>
<span class="c">        # this for-loop. Use the absolute value function to check.</span>
<span class="c">        error &lt;- (x - approximate_root * approximate_root) / x</span>

<span class="c">        if (abs(error) &lt; epsilon) {</span>
<span class="c">            break</span>
<span class="c">        }</span>

<span class="c">        # Apply Heron&#39;s method to get a better approximation for the root.</span>
<span class="c">        approximate_root &lt;- 0.5 * (approximate_root + x / approximate_root)</span>
<span class="c">    }</span>

<span class="c">    # As long as x is positive and not very large, we should have a very</span>
<span class="c">    # good approximation for sqrt(x). Heron&#39;s method will still work for</span>
<span class="c">    # very large x, but we must increase maximum_number_of_iterations.</span>
<span class="c">    return(approximate_root)</span>
<span class="c">}</span>

<span class="c"># Test out the function, try computing sqrt(2).</span>
<span class="c">x_val &lt;- 2.0</span>
<span class="c">sqrt_2 &lt;- herons_method(x_val)</span>
<span class="c">output &lt;- sprintf(&quot;sqrt(%.1f) = %.16f&quot;, x_val, sqrt_2)</span>
<span class="c">message(output)</span>

<span class="c"># We can run this by installing R.</span>
<span class="c">#   https://www.r-project.org/</span>
<span class="c"># Once installed, type:</span>
<span class="c">#   Rscript herons_method.r</span>
<span class="c"># This will output:</span>
<span class="c">#   sqrt(2.0) = 1.4142135623730949</span>
<span class="c"># This has relative error 1.570092458683775E-16.</span>
</pre></div>

<h2 id="rust">Rust<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/08                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Computes the square root of a positive real number via Heron&#39;s method.    */</span>
<span class="k">fn</span> <span class="nf">herons_method</span><span class="p">(</span><span class="n">x</span>: <span class="kt">f64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is double precision epsilon.          */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">EPSILON</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Set the initial guess to the input. Provided x is positive, Heron&#39;s   *</span>
<span class="cm">     *  method will indeed converge.                                          */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">approximate_root</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Iteratively loop through and obtain better approximations for sqrt(x).*/</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If we are within epsilon of the correct value we may break out of *</span>
<span class="cm">         *  this for-loop. Use the absolute value function to check.          */</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">error</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">EPSILON</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Apply Heron&#39;s method to get a better approximation for the root.  */</span>
<span class="w">        </span><span class="n">approximate_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">approximate_root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  As long as x is positive and not very large, we should have a very    *</span>
<span class="cm">     *  good approximation for sqrt(x). Heron&#39;s method will still work for    *</span>
<span class="cm">     *  very large x, but we must increase MAXIMUM_NUMBER_OF_ITERATIONS.      */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">approximate_root</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of herons_method.                                                     */</span>

<span class="cm">/*  Main routine used for testing our implementation of Heron&#39;s method.       */</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  The input to Heron&#39;s method, the value we want to compute the square  *</span>
<span class="cm">     *  root of.                                                              */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Calculate the square root and print it to the screen. If we have      *</span>
<span class="cm">     *  written things correctly, we should get 1.414..., which is sqrt(2).   */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sqrt_x</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="n">herons_method</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;sqrt({}) = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt_x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  We can run this by installing the standard rust compiler, rustc:          *</span>
<span class="cm"> *      https://www.rust-lang.org/tools/install                               *</span>
<span class="cm"> *  On GNU, Linux, FreeBSD, macOS, etc., we can run this by typing:           *</span>
<span class="cm"> *      rustc herons_method.rs -o main                                        *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  This will output the following:                                           *</span>
<span class="cm"> *      sqrt(2.0) = 1.414213562373095                                         *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On Windows, type:                                                         *</span>
<span class="cm"> *      rustc herons_method.rs -o main.exe                                    *</span>
<span class="cm"> *      main.exe                                                              *</span>
<span class="cm"> *  This will produce the same output.                                        */</span>
</pre></div>

<h2 id="swift">Swift<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/08                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  fabs (floating-point absolute value) found here.                          */</span>
<span class="kd">import</span> <span class="nc">Foundation</span>

<span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This means  *</span>
<span class="cm"> *  that if a_{n} has N correct decimals, then a_{n+1} will have 2N correct   *</span>
<span class="cm"> *  decimals. A standard 64-bit double can fit about 16 decimals of precision *</span>
<span class="cm"> *  (the exact value is 2^-52 ~= 2.22x10^-16). Because of this we may exit    *</span>
<span class="cm"> *  the function after a few iterations.                                      */</span>
<span class="kd">let</span> <span class="nv">maximum_number_of_iterations</span><span class="p">:</span> <span class="nb">UInt32</span> <span class="p">=</span> <span class="mi">16</span>

<span class="cm">/*  The maximum allowed error. This is double precision epsilon.              */</span>
<span class="kd">let</span> <span class="nv">epsilon</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">2.220446049250313E-16</span>

<span class="cm">/*  Function for computing square roots using Heron&#39;s method.                 */</span>
<span class="kd">func</span> <span class="nf">heronsMethod</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Double</span> <span class="p">{</span>

    <span class="cm">/*  Starting value for Heron&#39;s method. The input will suffice.            */</span>
    <span class="kd">var</span> <span class="nv">approximate_root</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="n">x</span>

    <span class="cm">/*  Loop through and iteratively perform Heron&#39;s method.                  */</span>
    <span class="k">for</span> <span class="kc">_</span> <span class="k">in</span> <span class="mi">0</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">maximum_number_of_iterations</span> <span class="p">{</span>

        <span class="cm">/*  If the error is small enough we can break out of the loop. We     *</span>
<span class="cm">         *  want small relative error, so compute this.                       */</span>
        <span class="kd">let</span> <span class="nv">error</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">approximate_root</span> <span class="o">*</span> <span class="n">approximate_root</span><span class="p">)</span> <span class="o">/</span> <span class="n">x</span>

        <span class="k">if</span> <span class="n">fabs</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">epsilon</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>

        <span class="cm">/*  Otherwise improve the error by applying Heron&#39;s method.           */</span>
        <span class="n">approximate_root</span> <span class="p">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">approximate_root</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">approximate_root</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="cm">/*  As long as x is positive and not very large, we should have a very    *</span>
<span class="cm">     *  good approximation for sqrt(x). Heron&#39;s method works for large x, but *</span>
<span class="cm">     *  we may need to increasethe value of maximum_number_of_iterations.     */</span>
    <span class="k">return</span> <span class="n">approximate_root</span>
<span class="p">}</span>

<span class="cm">/*  Test out Heron&#39;s method by computing sqrt(2).                             */</span>
<span class="kd">let</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">2.0</span>
<span class="kd">let</span> <span class="nv">sqrt_x</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="n">heronsMethod</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;sqrt(</span><span class="si">\(</span><span class="n">x</span><span class="si">)</span><span class="s">) = </span><span class="si">\(</span><span class="n">sqrt_x</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>

<span class="cm">/*  We can run this using the standard swift compiler, swiftc:                *</span>
<span class="cm"> *      https://www.swift.org/install/                                        *</span>
<span class="cm"> *  After installing, on GNU, Linux, or macOS, type:                          *</span>
<span class="cm"> *      swiftc herons_method.swift -o main                                    *</span>
<span class="cm"> *      ./main                                                                *</span>
<span class="cm"> *  This will output the following:                                           *</span>
<span class="cm"> *      sqrt(2.0) = 1.414213562373095                                         *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  On Windows, type:                                                         *</span>
<span class="cm"> *      swiftc herons_method.swift -o main.exe                                *</span>
<span class="cm"> *      main.exe                                                              *</span>
<span class="cm"> *  This will produce the same output.                                        */</span>
</pre></div>

<h2 id="typescript">TypeScript<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates square roots using Heron&#39;s method.                         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/05/18                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Computes the square root of a positive real number via Heron&#39;s method.    */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">heronsMethod</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Heron&#39;s method is iterative and the convergence is quadratic. This    *</span>
<span class="cm">     *  means that if a_{n} has N correct decimals, then a_{n+1} will have    *</span>
<span class="cm">     *  2N correct decimals. A standard 64-bit double can fit about 16        *</span>
<span class="cm">     *  decimals of precision (the exact value is 2^-52 ~= 2.22x10^-16).      *</span>
<span class="cm">     *  Because of this we may exit the function after a few iterations.      */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is double precision epsilon.          */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">EPSILON</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of how many iterations we have performed.  */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">iters</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Set the initial guess to the input. Provided x is positive, Heron&#39;s   *</span>
<span class="cm">     *  method will indeed converge.                                          */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Iteratively loop through and obtain better approximations for sqrt(x).*/</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="nx">iters</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If we are within epsilon of the correct value we may break out of *</span>
<span class="cm">         *  this for-loop. Use the absolute value function to check.          */</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">x</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Apply Heron&#39;s method to get a better approximation for the root.  */</span>
<span class="w">        </span><span class="nx">approximateRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">approximateRoot</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  As long as x is positive and not very large, we should have a very    *</span>
<span class="cm">     *  good approximation for sqrt(x). Heron&#39;s method will still work for    *</span>
<span class="cm">     *  very large x, but we must increase MAXIMUM_NUMBER_OF_ITERATIONS.      */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">approximateRoot</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of heronsMethod.                                                      */</span>

<span class="cm">/*  Test out our function, compute sqrt(2) and print it to the screen.        */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">X</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">SQRT_2</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">heronsMethod</span><span class="p">(</span><span class="nx">X</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">output</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;sqrt(2) = &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">SQRT_2</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mf">16</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span>

<span class="cm">/*  We can run this by installing node.js and tsx:                            *</span>
<span class="cm"> *      https://nodejs.org/en                                                 *</span>
<span class="cm"> *  Using the node package manager (npm), install tsx by typing:              *</span>
<span class="cm"> *      npm install -g tsx                                                    *</span>
<span class="cm"> *  Run the file by typing:                                                   *</span>
<span class="cm"> *      npx tsx herons_method.ts                                              *</span>
<span class="cm"> *  This will output the following:                                           *</span>
<span class="cm"> *      sqrt(2.0) = 1.4142135623730949                                        *</span>
<span class="cm"> *  This has a relative error of 1.570092458683775E-16.                       */</span>
</pre></div>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ryan Maguire</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ryan Maguire</li><li><a class="u-email" href="mailto:rmaguire@protonmail.com">rmaguire@protonmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ryanmaguire"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ryanmaguire</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Mathematics, Physics, and Programming</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
