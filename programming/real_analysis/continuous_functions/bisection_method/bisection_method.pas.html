<div class="highlight"><pre><span></span><span class="cm">(******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General Public*</span>
<span class="cm"> *  License as published by the Free Software Foundation, either version 3 of *</span>
<span class="cm"> *  the License, or (at your option) any later version.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that it  *</span>
<span class="cm"> *  will be useful but WITHOUT ANY WARRANTY; without even the implied warranty*</span>
<span class="cm"> *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *</span>
<span class="cm"> *  GNU General Public License for more details.                              *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples.  If not, see            *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Computes roots using the bisection method.                            *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/04/17                                                        *</span>
<span class="cm"> ******************************************************************************)</span>
<span class="k">PROGRAM</span><span class="w"> </span><span class="n">Bisection</span><span class="o">;</span>

<span class="cm">(*  We define two constants: The allowed tolerance (or epsilon value),        *</span>
<span class="cm"> *  and the maximum number of iterations we allow for the bisection method.   *)</span>
<span class="k">CONST</span>

<span class="w">    </span><span class="cm">(*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 *)</span>
<span class="w">    </span><span class="n">MaximumNumberOfIterations</span><span class="o">:</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Maximum allowed error. This is double precision epsilon.              *)</span>
<span class="w">    </span><span class="n">Epsilon</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Pi is between 2 and 4 and is a root to sine.                          *)</span>
<span class="w">    </span><span class="n">LeftValue</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">;</span>
<span class="w">    </span><span class="n">RightValue</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="o">;</span>

<span class="cm">(*  Create an alias for real functions f: R -&gt; R. This makes the syntax of    *</span>
<span class="cm"> *  the parameters for the BisectionMethod function a little more readable.   *)</span>
<span class="k">TYPE</span>
<span class="w">    </span><span class="n">RealFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">Function</span><span class="p">(</span><span class="k">Const</span><span class="w"> </span><span class="n">X</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="cm">(*  The main program only has one variable, pi computed via bisection.        *)</span>
<span class="k">VAR</span>
<span class="w">    </span><span class="n">PiByBisection</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="cm">(*  Sin is a built-in procedure. Create a function Real -&gt; Real that computes *</span>
<span class="cm"> *  sin(x) so that we may pass it as a parameter to BisectionMethod.          *)</span>
<span class="k">Function</span><span class="w"> </span><span class="nf">Sine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>
<span class="k">BEGIN</span>
<span class="w">    </span><span class="n">Sine</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">SIN</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">;</span>
<span class="k">END</span><span class="o">;</span>

<span class="cm">(******************************************************************************</span>
<span class="cm"> *  Function:                                                                 *</span>
<span class="cm"> *      BisectionMethod                                                       *</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Computes roots using the bisection method.                            *</span>
<span class="cm"> *   Arguments:                                                               *</span>
<span class="cm"> *       F (RealFunc):                                                        *</span>
<span class="cm"> *           A function from [A, B] to the real numbers.                      *</span>
<span class="cm"> *       A (Real):                                                            *</span>
<span class="cm"> *           One of the endpoints for the interval.                           *</span>
<span class="cm"> *       B (Real):                                                            *</span>
<span class="cm"> *           The other the endpoint for the interval.                         *</span>
<span class="cm"> *   OUTPUT:                                                                  *</span>
<span class="cm"> *       Root (Real):                                                         *</span>
<span class="cm"> *           A root for F between A and B.                                    *</span>
<span class="cm"> ******************************************************************************)</span>
<span class="k">Function</span><span class="w"> </span><span class="nf">BisectionMethod</span><span class="p">(</span><span class="k">Const</span><span class="w"> </span><span class="n">F</span><span class="o">:</span><span class="w"> </span><span class="n">RealFunc</span><span class="o">;</span><span class="w"> </span><span class="k">Const</span><span class="w"> </span><span class="n">A</span><span class="o">,</span><span class="w"> </span><span class="n">B</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="k">VAR</span>
<span class="w">    </span><span class="cm">(*  We do not require A &lt; B, nor F(A) &lt; F(B). We will use Left and Right  *</span>
<span class="cm">     *  to re-orient the interval so that F(Left) &lt; F(Right). Midpoint will   *</span>
<span class="cm">     *  be the center of the interval, and these three values will be updated *</span>
<span class="cm">     *  iteratively as we perform the bisection method.                       *)</span>
<span class="w">    </span><span class="n">Left</span><span class="o">,</span><span class="w"> </span><span class="n">Right</span><span class="o">,</span><span class="w"> </span><span class="n">Midpoint</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Variables for the evaluation of F at A, B, and Midpoint, respectively.*)</span>
<span class="w">    </span><span class="n">AEval</span><span class="o">,</span><span class="w"> </span><span class="n">BEval</span><span class="o">,</span><span class="w"> </span><span class="n">Eval</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Dummy variable for tracking how many iterations we&#39;ve performed.      *)</span>
<span class="w">    </span><span class="n">Iters</span><span class="o">:</span><span class="w"> </span><span class="kt">Integer</span><span class="o">;</span>

<span class="k">LABEL</span>
<span class="w">    </span><span class="cm">(*  Several spots allow for early returns in the function. We use a       *</span>
<span class="cm">     *  single label for GOTO to allow us to break out of the function.       *)</span>
<span class="w">    </span><span class="nl">Finished</span><span class="o">;</span>

<span class="k">BEGIN</span>

<span class="w">    </span><span class="cm">(*  Initial setup, find out which evaluation is positive and which is     *</span>
<span class="cm">     *  negative. If the signs of the two agree we treat this as an error.    *)</span>
<span class="w">    </span><span class="n">AEval</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">;</span>
<span class="w">    </span><span class="n">BEval</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Special case, A is a root. Set the output to A and return.            *)</span>
<span class="w">    </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">AEval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Epsilon</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">    </span><span class="k">BEGIN</span>
<span class="w">        </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">A</span><span class="o">;</span>
<span class="w">        </span><span class="k">GOTO</span><span class="w"> </span><span class="nl">Finished</span><span class="o">;</span>
<span class="w">    </span><span class="k">END</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Similarly for B, if F(B) ~= 0, return B.                              *)</span>
<span class="w">    </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">BEval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Epsilon</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">    </span><span class="k">BEGIN</span>
<span class="w">        </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">B</span><span class="o">;</span>
<span class="w">        </span><span class="k">GOTO</span><span class="w"> </span><span class="nl">Finished</span><span class="o">;</span>
<span class="w">    </span><span class="k">END</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  If F(A) &lt; 0 &lt; F(B), then Left = A and Right = B.                      *)</span>
<span class="w">    </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="n">AEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BEval</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">    </span><span class="k">BEGIN</span>

<span class="w">        </span><span class="cm">(*  If F(A) and F(B) have the same sign (both positive or</span>
<span class="cm">         *  both negative), return NaN. Bisection is undefined.               *)</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">((</span><span class="n">AEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="p">(</span><span class="n">BEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">        </span><span class="k">BEGIN</span>
<span class="w">            </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="o">;</span>
<span class="w">            </span><span class="k">GOTO</span><span class="w"> </span><span class="nl">Finished</span><span class="o">;</span>
<span class="w">        </span><span class="k">END</span><span class="o">;</span>

<span class="w">        </span><span class="n">Left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">A</span><span class="o">;</span>
<span class="w">        </span><span class="n">Right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">B</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  If F(B) &lt; 0 &lt; F(A), then Left = B and Right = A.                      *)</span>
<span class="w">    </span><span class="k">END</span>
<span class="w">    </span><span class="k">ELSE</span>
<span class="w">    </span><span class="k">BEGIN</span>

<span class="w">        </span><span class="cm">(*  Same sanity check as before, make sure the signs are different.   *)</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">((</span><span class="n">AEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="p">(</span><span class="n">BEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">        </span><span class="k">BEGIN</span>
<span class="w">            </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="o">;</span>
<span class="w">            </span><span class="k">GOTO</span><span class="w"> </span><span class="nl">Finished</span><span class="o">;</span>
<span class="w">        </span><span class="k">END</span><span class="o">;</span>

<span class="w">        </span><span class="n">Left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">B</span><span class="o">;</span>
<span class="w">        </span><span class="n">Right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">A</span><span class="o">;</span>
<span class="w">    </span><span class="k">END</span><span class="o">;</span>

<span class="w">    </span><span class="n">Midpoint</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Iteratively perform the bisection method.                             *)</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="n">Iters</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="n">MaximumNumberOfIterations</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">DO</span>
<span class="w">    </span><span class="k">BEGIN</span>

<span class="w">        </span><span class="cm">(*  The interval is cut in half based on the sign of F(Midpoint).     *</span>
<span class="cm">         *  Compute this and compare.                                         *)</span>
<span class="w">        </span><span class="n">Eval</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">Midpoint</span><span class="p">)</span><span class="o">;</span>

<span class="w">        </span><span class="cm">(*  If MIDPOINT is close to a root we can exit the function.          *)</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">Eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Epsilon</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="k">BREAK</span><span class="o">;</span>

<span class="w">        </span><span class="cm">(*  Otherwise, divide the range in half. If Eval is negative we       *</span>
<span class="cm">         *  replace Left with Midpoint and move Midpoint closer to Right.     *)</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="n">Eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="k">BEGIN</span>
<span class="w">            </span><span class="n">Left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Midpoint</span><span class="o">;</span>
<span class="w">            </span><span class="n">Midpoint</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Right</span><span class="p">)</span><span class="o">;</span>

<span class="w">        </span><span class="cm">(*  Likewise, if Eval is positive, replace Right with Midpoint and    *</span>
<span class="cm">         *  move Midpoint closer to Left.                                     *)</span>
<span class="w">        </span><span class="k">END</span><span class="w"> </span><span class="k">ELSE</span><span class="w"> </span><span class="k">BEGIN</span>
<span class="w">            </span><span class="n">Right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Midpoint</span><span class="o">;</span>
<span class="w">            </span><span class="n">Midpoint</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Midpoint</span><span class="p">)</span><span class="o">;</span>
<span class="w">        </span><span class="k">END</span><span class="o">;</span>
<span class="w">    </span><span class="k">END</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Provided |B - A| is not too big, we should now have a very good       *</span>
<span class="cm">     *  approximation to the root.                                            *)</span>
<span class="w">    </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Midpoint</span><span class="o">;</span>

<span class="w">    </span><span class="nl">Finished</span><span class="o">:</span>
<span class="k">END</span><span class="o">;</span>

<span class="cm">(*  Program for testing our implementation of the bisection method.           *)</span>
<span class="k">BEGIN</span>

<span class="w">    </span><span class="cm">(*  Pi is between 2 and 4 and is a root to sine.                          *)</span>
<span class="w">    </span><span class="n">PiByBisection</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">BisectionMethod</span><span class="p">(</span><span class="o">@</span><span class="n">Sine</span><span class="o">,</span><span class="w"> </span><span class="n">LeftValue</span><span class="o">,</span><span class="w"> </span><span class="n">RightValue</span><span class="p">)</span><span class="o">;</span>
<span class="w">    </span><span class="nb">WriteLn</span><span class="p">(</span><span class="s">&#39;pi = &#39;</span><span class="o">,</span><span class="w"> </span><span class="n">PiByBisection</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">16</span><span class="p">)</span><span class="o">;</span>

<span class="k">END</span><span class="o">.</span>
</pre></div>
