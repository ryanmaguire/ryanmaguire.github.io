<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using the bisection method.         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/29                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  NSObject, base class for all Objective-C classes, found here. math.h and  *</span>
<span class="cm"> *  stdio.h are also included in this header file.                            */</span>
<span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="cm">/*  Function pointer notation is a little confusing. Create a typedef for it  *</span>
<span class="cm"> *  so we do not need to explicitly use it later.                             */</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>

<span class="cm">/*  Class providing an implementation of the bisection method.                */</span>
<span class="k">@interface</span> <span class="nc">Bisection</span>: <span class="bp">NSObject</span>
    <span class="p">{</span>
<span class="w">        </span><span class="cm">/*  How many iterations of the Bisection method we do before exiting. */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Allowed tolerance for the root-finding method.                    */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Given a function f: R -&gt; R and two real numbers a and b, this finds   *</span>
<span class="cm">     *  a root of f between a and b using the bisection method.               */</span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">root</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">function</span><span class="p">)</span><span class="n">f</span><span class="w"> </span><span class="n">start</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">a</span><span class="w"> </span><span class="n">finish</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Bisection</span>

<span class="w">    </span><span class="cm">/*  The error after n iterations is |b - a| / 2^n. Since double has a     *</span>
<span class="cm">     *  52-bit mantissa, if |b - a| ~= 1, then after 52 steps we can halt the *</span>
<span class="cm">     *  program. To allow for |b - a| to be larger, we stop the process after *</span>
<span class="cm">     *  at most 64 iterations.                                                */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is double precision epsilon.          */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Computes the root of a function using the bisection method.           */</span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">root</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">function</span><span class="p">)</span><span class="n">f</span><span class="w"> </span><span class="n">start</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">a</span><span class="w"> </span><span class="n">finish</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">b</span>
<span class="w">    </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  Variable for keeping track of the number of iterations.           */</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  The midpoint for the bisection. This updates as we iterate.       */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  We do not require a &lt; b, nor f(a) &lt; f(b). We need one of          *</span>
<span class="cm">         *  these to evaluate negative under f and one to evaluate to         *</span>
<span class="cm">         *  positive. Call the negative entry left and positive one right.    */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Evaluate f at the endpoints to determine which is positive        *</span>
<span class="cm">         *  and which is negative, transforming [a, b] to [left, right].      */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">aEval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">bEval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.               */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Similarly, if f(b) = 0, then we found the root. Return b.         */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bEval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Compare the two evaluations and set the left and right values.    */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bEval</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  If both evaluations are negative, or if both are positive,    *</span>
<span class="cm">             *  then the bisection method will not work. Return NaN.          */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">aEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.     */</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  In this case the function starts positive and goes negative.      */</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be     *</span>
<span class="cm">             *  negative and one to be positive. Abort if the signs agree.    */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">bEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                */</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.      */</span>
<span class="w">        </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Iteratively divide the range in half to find the root.            */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  If f(x) is very small, we are close to a root and can         *</span>
<span class="cm">             *  break out of this for loop. Check for this.                   */</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Apply bisection to get a better approximation. We have        *</span>
<span class="cm">             *  f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the       *</span>
<span class="cm">             *  interval [left, right] with [midpoint, right]. Set left       *</span>
<span class="cm">             *  to the midpoint and set midpoint to be closer to right.       */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">                </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/*  If f(midpoint) &gt; 0, then replace right with the midpoint,     *</span>
<span class="cm">             *  changing [left, right] into [left, midpoint]. We then set     *</span>
<span class="cm">             *  the midpoint to be closer to left.                            */</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">                </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  After n iterations, we are at most |b - a| / 2^n from the         *</span>
<span class="cm">         *  root of the function. 1 / 2^n goes to zero very quickly,          *</span>
<span class="cm">         *  meaning the convergence is very quick.                            */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/*  End of root.                                                          */</span>
<span class="k">@end</span>
<span class="cm">/*  End of Bisection implementation.                                          */</span>

<span class="cm">/*  Main routine used for testing our implementation of the Bisection method. */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.            */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate   *</span>
<span class="cm">     *  to about 16 decimals.                                                 */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">Bisection</span><span class="w"> </span><span class="n">root</span><span class="o">:</span><span class="w"> </span><span class="n">sin</span><span class="w"> </span><span class="n">start</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">finish</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">];</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;pi = %.16f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
