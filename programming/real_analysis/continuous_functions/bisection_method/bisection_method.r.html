<div class="highlight"><pre><span></span><span class="c">################################################################################</span>
<span class="c">#                                   LICENSE                                    #</span>
<span class="c">################################################################################</span>
<span class="c">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="c">#   redistribute it and/or modify it under the terms of the GNU General Public #</span>
<span class="c">#   License as published by the Free Software Foundation, either version 3 of  #</span>
<span class="c">#   the License, or (at your option) any later version.                        #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is distributed in the hope that it   #</span>
<span class="c">#   will be useful, but WITHOUT ANY WARRANTY; without even the implied         #</span>
<span class="c">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  #</span>
<span class="c">#   GNU General Public License for more details.                               #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   You should have received a copy of the GNU General Public License          #</span>
<span class="c">#   along with mitx_mathematics_programming_examples.  If not, see             #</span>
<span class="c">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="c">################################################################################</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Calculates roots of a function using bisection.                        #</span>
<span class="c">################################################################################</span>
<span class="c">#   Author:     Ryan Maguire                                                   #</span>
<span class="c">#   Date:       May 18, 2025.                                                  #</span>
<span class="c">################################################################################</span>

<span class="c"># Computes the root of a function via bisection.</span>
<span class="c">bisection &lt;- function(f, a, b) {</span>

<span class="c">    # Tell the algorithm to stop after several iterations to avoid an</span>
<span class="c">    # infinite loop. Double precision numbers have 52 bits in the mantissa,</span>
<span class="c">    # so if |b - a| ~= 1, after 52 iterations of bisection we will get as</span>
<span class="c">    # close as we can to the root. To allow for |b - a| to be larger, halt</span>
<span class="c">    # the algorithm after at most 64 steps.</span>
<span class="c">    maximum_number_of_iterations &lt;- 64</span>

<span class="c">    # The maximum allowed error. This is double precision epsilon.</span>
<span class="c">    epsilon &lt;- 2.220446049250313E-16</span>

<span class="c">    # Evaluate f at the two endpoints to determine which is positive and</span>
<span class="c">    # which is negative. We transform [a, b] to [left, right] by doing this.</span>
<span class="c">    a_eval &lt;- f(a)</span>
<span class="c">    b_eval &lt;- f(b)</span>

<span class="c">    # Rare case, f(a) = 0. Return a, no bisection needed.</span>
<span class="c">    if (a_eval == 0.0) {</span>
<span class="c">        return(a)</span>
<span class="c">    }</span>

<span class="c">    # Similarly, if f(b) = 0, then we have already found the root. Return b.</span>
<span class="c">    if (b_eval == 0.0) {</span>
<span class="c">        return(b)</span>
<span class="c">    }</span>

<span class="c">    # Compare the two evaluations and set left and right accordingly.</span>
<span class="c">    if (a_eval &lt; b_eval) {</span>

<span class="c">        # If both evaluations are negative, or if both are positive, then</span>
<span class="c">        # the bisection method will not work. Return NaN.</span>
<span class="c">        if ((b_eval &lt; 0.0) || (a_eval &gt; 0.0)) {</span>
<span class="c">            return((a - a) / (a - a))</span>
<span class="c">        }</span>

<span class="c">        # Otherwise, since f(a) &lt; f(b), set left = a and right = b.</span>
<span class="c">        left &lt;- a</span>
<span class="c">        right &lt;- b</span>

<span class="c">    # In this case the function starts positive and tends to a negative.</span>
<span class="c">    } else {</span>

<span class="c">        # Same sanity check as before. We need one evaluation to be</span>
<span class="c">        # negative and one to be positive. Abort if both have the same sign.</span>
<span class="c">        if ((a_eval &lt; 0.0) || (b_eval &gt; 0.0)) {</span>
<span class="c">            return((a - a) / (a - a))</span>
<span class="c">        }</span>

<span class="c">        # Since f(a) &gt; f(b), set left = b and right = a.</span>
<span class="c">        left &lt;- b</span>
<span class="c">        right &lt;- a</span>
<span class="c">    }</span>

<span class="c">    # Start the bisection method. Compute the midpoint of a and b.</span>
<span class="c">    midpoint &lt;- 0.5 * (a + b)</span>

<span class="c">    # Iteratively apply the bisection method.</span>
<span class="c">    for (iters in 1:maximum_number_of_iterations) {</span>

<span class="c">        # If f(x) is very small, we are close to a root and can break out</span>
<span class="c">        # of this for loop. Check for this.</span>
<span class="c">        f_eval &lt;- f(midpoint)</span>

<span class="c">        if (abs(f_eval) &lt;= epsilon) {</span>
<span class="c">            break</span>
<span class="c">        }</span>

<span class="c">        # Apply bisection to get a better approximation for the root. We</span>
<span class="c">        # have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the</span>
<span class="c">        # interval [left, right] with [midpoint, right]. Set left to the</span>
<span class="c">        # midpoint and reset the midpoint to be closer to right.</span>
<span class="c">        if (f_eval &lt; 0.0) {</span>
<span class="c">            left &lt;- midpoint</span>
<span class="c">            midpoint &lt;- 0.5 * (midpoint + right)</span>

<span class="c">        # In the other case, f(midpoint) &gt; 0, we replace right with the</span>
<span class="c">        # midpoint, changing [left, right] into [left, midpoint]. We then</span>
<span class="c">        # set the midpoint to be closer to left.</span>
<span class="c">        } else {</span>
<span class="c">            right &lt;- midpoint</span>
<span class="c">            midpoint &lt;- 0.5 * (left + midpoint)</span>
<span class="c">        }</span>
<span class="c">    }</span>

<span class="c">    # After n iterations, we are no more than |b - a| / 2^n away from the</span>
<span class="c">    # root of the function. 1 / 2^n goes to zero very quickly, meaning the</span>
<span class="c">    # convergence is very quick.</span>
<span class="c">    return(midpoint)</span>
<span class="c">}</span>

<span class="c"># pi is somewhere between 3 and 4, and it is a root to sine.</span>
<span class="c">A &lt;- 3.0</span>
<span class="c">B &lt;- 4.0</span>

<span class="c"># Compute pi using bisection. We should get pi = 3.14159..., accurate</span>
<span class="c"># to about 16 decimals.</span>
<span class="c">pi_by_bisection &lt;- bisection(sin, A, B)</span>
<span class="c">output = sprintf(&quot;pi = %.16f&quot;, pi_by_bisection)</span>
<span class="c">message(output)</span>
</pre></div>
