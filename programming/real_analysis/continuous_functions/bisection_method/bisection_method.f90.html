<div class="highlight"><pre><span></span><span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!                                   LICENSE                                    !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!   This file is part of mitx_mathematics_programming_examples.                !</span>
<span class="c">!                                                                              !</span>
<span class="c">!   mitx_mathematics_programming_examples is free software: you can            !</span>
<span class="c">!   redistribute it and/or modify it under the terms of the GNU General Public !</span>
<span class="c">!   License as published by the Free Software Foundation, either version 3 of  !</span>
<span class="c">!   the License, or (at your option) any later version.                        !</span>
<span class="c">!                                                                              !</span>
<span class="c">!   mitx_mathematics_programming_examples is distributed in the hope that it   !</span>
<span class="c">!   will be useful but WITHOUT ANY WARRANTY; without even the implied warranty !</span>
<span class="c">!   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           !</span>
<span class="c">!   GNU General Public License for more details.                               !</span>
<span class="c">!                                                                              !</span>
<span class="c">!   You should have received a copy of the GNU General Public License          !</span>
<span class="c">!   along with mitx_mathematics_programming_examples.  If not, see             !</span>
<span class="c">!   &lt;https://www.gnu.org/licenses/&gt;.                                           !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!   Purpose:                                                                   !</span>
<span class="c">!       Calculates roots using the bisection method.                           !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!   Author: Ryan Maguire                                                       !</span>
<span class="c">!   Date:   2025/03/09                                                         !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="k">MODULE </span><span class="n">BISECTION</span>

<span class="w">    </span><span class="k">IMPLICIT NONE</span>

<span class="w">    </span><span class="c">! Given a continuous function defined on [a, b], the nth iteration of the</span>
<span class="w">    </span><span class="c">! bisection method is at most |b - a| / 2^n away from the root. A double</span>
<span class="w">    </span><span class="c">! precision number has 52 bits in the mantissa, meaning if |b - a| ~= 1,</span>
<span class="w">    </span><span class="c">! then after 52 iterations we are as close to the root as we can get.</span>
<span class="w">    </span><span class="c">! To allow for a larger range, halt the algorithm after 64 iterations.</span>
<span class="w">    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span>

<span class="w">    </span><span class="c">! Maximum allowed error. This is double precision epsilon.</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">EPSILON</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span>

<span class="w">    </span><span class="k">CONTAINS</span>

<span class="w">    </span><span class="c">!--------------------------------------------------------------------------!</span>
<span class="w">    </span><span class="c">!   Function:                                                              !</span>
<span class="w">    </span><span class="c">!       BISECTION_METHOD                                                   !</span>
<span class="w">    </span><span class="c">!   Purpose:                                                               !</span>
<span class="w">    </span><span class="c">!       Computes roots using the bisection method.                         !</span>
<span class="w">    </span><span class="c">!   Arguments:                                                             !</span>
<span class="w">    </span><span class="c">!       FUNC (FUNCTION):                                                   !</span>
<span class="w">    </span><span class="c">!           A function from [A, B] to the real numbers.                    !</span>
<span class="w">    </span><span class="c">!       A (REAL):                                                          !</span>
<span class="w">    </span><span class="c">!           One of the endpoints for the interval.                         !</span>
<span class="w">    </span><span class="c">!       B (REAL):                                                          !</span>
<span class="w">    </span><span class="c">!           The other the endpoint for the interval.                       !</span>
<span class="w">    </span><span class="c">!   OUTPUT:                                                                !</span>
<span class="w">    </span><span class="c">!       ROOT (REAL):                                                       !</span>
<span class="w">    </span><span class="c">!           A root for FUNC.                                               !</span>
<span class="w">    </span><span class="c">!--------------------------------------------------------------------------!</span>
<span class="w">    </span><span class="k">FUNCTION </span><span class="n">BISECTION_METHOD</span><span class="p">(</span><span class="n">FUNC</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span>

<span class="w">        </span><span class="k">IMPLICIT NONE</span>

<span class="w">        </span><span class="c">! FUNC is a function f: [A, B] -&gt; Reals. Define this.</span>
<span class="w">        </span><span class="k">INTERFACE</span>
<span class="k">            FUNCTION </span><span class="n">FUNC</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="w">                </span><span class="k">IMPLICIT NONE</span>
<span class="k">                </span><span class="kt">REAL</span><span class="p">,</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">X</span>
<span class="w">                </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">FUNC</span>
<span class="w">            </span><span class="k">END FUNCTION </span><span class="n">FUNC</span>
<span class="w">        </span><span class="k">END INTERFACE</span>

<span class="w">        </span><span class="c">! The inputs are positive real numbers.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="p">,</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>

<span class="w">        </span><span class="c">! The output is also a positive real number, the root of FUNC.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">BISECTION_METHOD</span>

<span class="w">        </span><span class="c">! Dummy variable for keeping track of how many iterations we&#39;ve done.</span>
<span class="w">        </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ITERS</span>

<span class="w">        </span><span class="c">! The midpoint of the interval. The bisection method iteratively cuts</span>
<span class="w">        </span><span class="c">! the interval in half to find the root.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">MIDPOINT</span>

<span class="w">        </span><span class="c">! The endpoints of the current interval. These are updated with each</span>
<span class="w">        </span><span class="c">! iteration. We initially define LEFT so that FUNC(LEFT) &lt; 0, and</span>
<span class="w">        </span><span class="c">! similarly choose RIGHT to make 0 &lt; FUNC(RIGHT).</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">LEFT</span><span class="p">,</span><span class="w"> </span><span class="n">RIGHT</span>

<span class="w">        </span><span class="c">! The evaluations of A and B are used to determine LEFT and RIGHT.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">A_EVAL</span><span class="p">,</span><span class="w"> </span><span class="n">B_EVAL</span>

<span class="w">        </span><span class="c">! At each iteration we compute FUNC(MIDPOINT) and reset the interval</span>
<span class="w">        </span><span class="c">! depending on whether or not the value is positive.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">EVAL</span>

<span class="w">        </span><span class="c">! Initial setup, find out which evaluation is positive and which is</span>
<span class="w">        </span><span class="c">! negative. If the signs of the two agree we treat this as an error.</span>
<span class="w">        </span><span class="n">A_EVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">        </span><span class="n">B_EVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

<span class="w">        </span><span class="c">! Special case, A is a root. Set the output to A and return.</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">A_EVAL</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="n">LE</span><span class="p">.</span><span class="w"> </span><span class="nb">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">            </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>
<span class="w">            </span><span class="k">RETURN</span>
<span class="k">        END IF</span>

<span class="w">        </span><span class="c">! Similarly for B, if FUNC(B) ~= 0, return B.</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">B_EVAL</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="n">LE</span><span class="p">.</span><span class="w"> </span><span class="nb">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">            </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span>
<span class="w">            </span><span class="k">RETURN</span>
<span class="k">        END IF</span>

<span class="w">        </span><span class="c">! If FUNC(A) &lt; 0 &lt; FUNC(B), then LEFT = A and RIGHT = B.</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">LT</span><span class="p">.</span><span class="w"> </span><span class="n">B_EVAL</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>

<span class="w">            </span><span class="c">! If FUNC(A) and FUNC(B) have the same sign (both positive or</span>
<span class="w">            </span><span class="c">! both negative), return NaN. Bisection is undefined.</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="p">((</span><span class="n">A_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">GT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="nb">OR</span><span class="p">.</span><span class="w"> </span><span class="p">(</span><span class="n">B_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">LT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">                </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span>
<span class="w">                </span><span class="k">RETURN</span>
<span class="k">            END IF</span>

<span class="k">            </span><span class="n">LEFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>
<span class="w">            </span><span class="n">RIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span>

<span class="w">        </span><span class="c">! If FUNC(B) &lt; 0 &lt; FUNC(A), then LEFT = B and RIGHT = A.</span>
<span class="w">        </span><span class="k">ELSE</span>

<span class="w">            </span><span class="c">! Same sanity check as before, make sure the signs are different.</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="p">((</span><span class="n">A_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">LT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="nb">OR</span><span class="p">.</span><span class="w"> </span><span class="p">(</span><span class="n">B_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">GT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">                </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span>
<span class="w">                </span><span class="k">RETURN</span>
<span class="k">            END IF</span>

<span class="k">            </span><span class="n">LEFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span>
<span class="w">            </span><span class="n">RIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>
<span class="w">        </span><span class="k">END IF</span>

<span class="k">        </span><span class="n">MIDPOINT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">)</span>

<span class="w">        </span><span class="c">! Iteratively perform the bisection method.</span>
<span class="w">        </span><span class="k">DO </span><span class="n">ITERS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span>

<span class="w">            </span><span class="c">! The interval is cut in half based on the sign of FUNC(MIDPOINT).</span>
<span class="w">            </span><span class="c">! Compute this and compare.</span>
<span class="w">            </span><span class="n">EVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">MIDPOINT</span><span class="p">)</span>

<span class="w">            </span><span class="c">! If MIDPOINT is close to a root we can exit the function.</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">EVAL</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="n">LE</span><span class="p">.</span><span class="w"> </span><span class="nb">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">                </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIDPOINT</span>
<span class="w">                </span><span class="k">RETURN</span>
<span class="k">            END IF</span>

<span class="w">            </span><span class="c">! Otherwise, divide the range in half. If EVAL is negative we</span>
<span class="w">            </span><span class="c">! replace LEFT with MIDPOINT and move MIDPOINT closer to RIGHT.</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="n">EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">LT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">                </span><span class="n">LEFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIDPOINT</span>
<span class="w">                </span><span class="n">MIDPOINT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">MIDPOINT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">RIGHT</span><span class="p">)</span>

<span class="w">            </span><span class="c">! Likewise, if EVAL is positive, replace RIGHT with MIDPOINT and</span>
<span class="w">            </span><span class="c">! move MIDPOINT closer to LEFT.</span>
<span class="w">            </span><span class="k">ELSE</span>
<span class="k">                </span><span class="n">RIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIDPOINT</span>
<span class="w">                </span><span class="n">MIDPOINT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">LEFT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">MIDPOINT</span><span class="p">)</span>
<span class="w">            </span><span class="k">END IF</span>
<span class="k">        END DO</span>

<span class="w">        </span><span class="c">! Provided |B - A| is not too big, we should now have a very good</span>
<span class="w">        </span><span class="c">! approximation to the root.</span>
<span class="w">        </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIDPOINT</span>
<span class="w">    </span><span class="k">END FUNCTION </span><span class="n">BISECTION_METHOD</span>
<span class="k">END MODULE </span><span class="n">BISECTION</span>

<span class="c">! Program for testing our implementation of the bisection method.</span>
<span class="k">PROGRAM </span><span class="n">MAIN</span>

<span class="w">    </span><span class="k">USE </span><span class="n">BISECTION</span>
<span class="w">    </span><span class="k">IMPLICIT NONE</span>

<span class="w">    </span><span class="c">! We will compute pi by finding a root to sine on the interval [3, 4].</span>
<span class="w">    </span><span class="c">! The sine function is an intrinsic provided by Fortran.</span>
<span class="w">    </span><span class="k">INTRINSIC </span><span class="nb">SIN</span>

<span class="w">    </span><span class="c">! Pi is somewhere between 3 and 4, use this interval.</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span>

<span class="w">    </span><span class="c">! Variable for the output.</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">PI</span>

<span class="w">    </span><span class="c">! Run the routine, compute pi, and print the result.</span>
<span class="w">    </span><span class="n">PI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BISECTION_METHOD</span><span class="p">(</span><span class="nb">SIN</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span>
<span class="w">    </span><span class="k">PRINT</span><span class="w"> </span><span class="s2">&quot;(A,F18.16)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;pi = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PI</span>

<span class="k">END PROGRAM </span><span class="n">MAIN</span>
</pre></div>
