<div class="highlight"><pre><span></span><span class="c">################################################################################</span>
<span class="c">#                                   LICENSE                                    #</span>
<span class="c">################################################################################</span>
<span class="c">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="c">#   redistribute it and/or modify it under the terms of the GNU General Public #</span>
<span class="c">#   License as published by the Free Software Foundation, either version 3 of  #</span>
<span class="c">#   the License, or (at your option) any later version.                        #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is distributed in the hope that it   #</span>
<span class="c">#   will be useful, but WITHOUT ANY WARRANTY; without even the implied         #</span>
<span class="c">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  #</span>
<span class="c">#   GNU General Public License for more details.                               #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   You should have received a copy of the GNU General Public License          #</span>
<span class="c">#   along with mitx_mathematics_programming_examples.  If not, see             #</span>
<span class="c">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="c">################################################################################</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Calculates roots of a function using bisection.                        #</span>
<span class="c">################################################################################</span>
<span class="c">#   Author:     Ryan Maguire                                                   #</span>
<span class="c">#   Date:       March 29, 2025.                                                #</span>
<span class="c">################################################################################</span>

<span class="c">################################################################################</span>
<span class="c">#   Function:                                                                  #</span>
<span class="c">#       bisection                                                              #</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Computes the root of a function f between a and b.                     #</span>
<span class="c">#   Arguments:                                                                 #</span>
<span class="c">#       f (function):                                                          #</span>
<span class="c">#           A function f: R -&gt; R. The root of f is computed.                   #</span>
<span class="c">#       a (real):                                                              #</span>
<span class="c">#           One of the endpoints of the interval for f.                        #</span>
<span class="c">#       b (real):                                                              #</span>
<span class="c">#           The other endpoint for f.                                          #</span>
<span class="c">#   Output:                                                                    #</span>
<span class="c">#       root (real):                                                           #</span>
<span class="c">#           A root of the function f between a and b.                          #</span>
<span class="c">################################################################################</span>
<span class="k">function</span><span class="w"> </span><span class="n">bisection</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Tell the algorithm to stop after several iterations to avoid an</span>
<span class="w">    </span><span class="c"># infinite loop. Double precision numbers have 52 bits in the mantissa,</span>
<span class="w">    </span><span class="c"># so if |b - a| ~= 1, after 52 iterations of bisection we will get as</span>
<span class="w">    </span><span class="c"># close as we can to the root. To allow for |b - a| to be larger, halt</span>
<span class="w">    </span><span class="c"># the algorithm after at most 64 steps.</span>
<span class="w">    </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span>

<span class="w">    </span><span class="c"># The maximum allowed error. This is double precision epsilon.</span>
<span class="w">    </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span>

<span class="w">    </span><span class="c"># Evaluate f at the two endpoints to determine which is positive and</span>
<span class="w">    </span><span class="c"># which is negative. We transform [a, b] to [left, right] by doing this.</span>
<span class="w">    </span><span class="n">a_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="w">    </span><span class="n">b_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Rare case, f(a) = 0. Return a, no bisection needed.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># Similarly, if f(b) = 0, then we have already found the root. Return b.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># Compare the two evaluations and set left and right accordingly.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b_eval</span>

<span class="w">        </span><span class="c"># If both evaluations are negative, or if both are positive, then</span>
<span class="w">        </span><span class="c"># the bisection method will not work. Return NaN.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c"># Otherwise, since f(a) &lt; f(b), set left = a and right = b.</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span>

<span class="w">    </span><span class="c"># In this case the function starts positive and tends to a negative.</span>
<span class="w">    </span><span class="k">else</span>

<span class="w">        </span><span class="c"># Same sanity check as before. We need one evaluation to be</span>
<span class="w">        </span><span class="c"># negative and one to be positive. Abort if both have the same sign.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c"># Since f(a) &gt; f(b), set left = b and right = a.</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># Start the bisection method. Compute the midpoint of a and b.</span>
<span class="w">    </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Iteratively apply the bisection method.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">maximum_number_of_iterations</span>

<span class="w">        </span><span class="c"># If f(x) is very small, we are close to a root and can break out</span>
<span class="w">        </span><span class="c"># of this for loop. Check for this.</span>
<span class="w">        </span><span class="n">eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c"># Apply bisection to get a better approximation for the root. We</span>
<span class="w">        </span><span class="c"># have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the</span>
<span class="w">        </span><span class="c"># interval [left, right] with [midpoint, right]. Set left to the</span>
<span class="w">        </span><span class="c"># midpoint and reset the midpoint to be closer to right.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">)</span>

<span class="w">        </span><span class="c"># In the other case, f(midpoint) &gt; 0, we replace right with the</span>
<span class="w">        </span><span class="c"># midpoint, changing [left, right] into [left, midpoint]. We then</span>
<span class="w">        </span><span class="c"># set the midpoint to be closer to left.</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">)</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># After n iterations, we are no more than |b - a| / 2^n away from the</span>
<span class="w">    </span><span class="c"># root of the function. 1 / 2^n goes to zero very quickly, meaning the</span>
<span class="w">    </span><span class="c"># convergence is very quick.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span>

<span class="k">end</span>

<span class="c"># pi is somewhere between 3 and 4, and it is a root to sine.</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span>

<span class="c"># Compute pi using bisection. We should get pi = 3.14159..., accurate</span>
<span class="c"># to about 16 decimals.</span>
<span class="n">pi_by_bisection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bisection</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;pi = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi_by_bisection</span><span class="p">)</span>
</pre></div>
