<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ryan Maguire | Mathematics, Physics, and Programming</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Ryan Maguire" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Mathematics, Physics, and Programming" />
<meta property="og:description" content="Mathematics, Physics, and Programming" />
<link rel="canonical" href="https://github.com/ryanmaguire/programming/real_analysis/continuous_functions/bisection_method" />
<meta property="og:url" content="https://github.com/ryanmaguire/programming/real_analysis/continuous_functions/bisection_method" />
<meta property="og:site_name" content="Ryan Maguire" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ryan Maguire" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Mathematics, Physics, and Programming","headline":"Ryan Maguire","url":"https://github.com/ryanmaguire/programming/real_analysis/continuous_functions/bisection_method"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://github.com/ryanmaguire/feed.xml" title="Ryan Maguire" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Ryan Maguire</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/asymptote/">Asymptote</a><a class="page-link" href="/papers/">Papers</a><a class="page-link" href="/presentations/">Presentations</a><a class="page-link" href="/programming/">Programming</a><a class="page-link" href="/projects/">Projects</a><a class="page-link" href="/teaching/">Teaching</a><a class="page-link" href="/threejs/">Three.js</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <p><a href="../"><strong>Back</strong></a></p>

<h2 id="cs">Cs<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using the bisection method.         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/28                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Console.WriteLine and Math.Abs are both provided here.                    */</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="cm">/*  Create an alias for functions of the form f: R -&gt; R.                      */</span>
<span class="k">using</span><span class="w"> </span><span class="nn">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Func</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cm">/*  Class providing an implementation of the bisection method.                */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Bisection</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  The error after n iterations is |b - a| / 2^n. Since double has a     *</span>
<span class="cm">     *  52-bit mantissa, if |b - a| ~= 1, then after 52 steps we can halt the *</span>
<span class="cm">     *  program. To allow for |b - a| to be larger, we stop the process after *</span>
<span class="cm">     *  at most 64 iterations.                                                */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">64</span><span class="n">U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is double precision epsilon.          */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Computes the root of a function using the bisection method.           */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">Root</span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Variable for keeping track of the number of iterations.           */</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  The midpoint for the bisection. This updates as we iterate.       */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  We do not require a &lt; b, nor f(a) &lt; f(b). We need one of          *</span>
<span class="cm">         *  these to evaluate negative under f and one to evaluate to         *</span>
<span class="cm">         *  positive. Call the negative entry left and positive one right.    */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Evaluate f at the endpoints to determine which is positive        *</span>
<span class="cm">         *  and which is negative, transforming [a, b] to [left, right].      */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">aEval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">bEval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.               */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Similarly, if f(b) = 0, then we found the root. Return b.         */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bEval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Compare the two evaluations and set the left and right values.    */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bEval</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  If both evaluations are negative, or if both are positive,    *</span>
<span class="cm">             *  then the bisection method will not work. Return NaN.          */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">aEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.     */</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  In this case the function starts positive and goes negative.      */</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be     *</span>
<span class="cm">             *  negative and one to be positive. Abort if the signs agree.    */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">bEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                */</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.      */</span>
<span class="w">        </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Iteratively divide the range in half to find the root.            */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  If f(x) is very small, we are close to a root and can         *</span>
<span class="cm">             *  break out of this for loop. Check for this.                   */</span>
<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Apply bisection to get a better approximation. We have        *</span>
<span class="cm">             *  f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the       *</span>
<span class="cm">             *  interval [left, right] with [midpoint, right]. Set left       *</span>
<span class="cm">             *  to the midpoint and set midpoint to be closer to right.       */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">                </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/*  If f(midpoint) &gt; 0, then replace right with the midpoint,     *</span>
<span class="cm">             *  changing [left, right] into [left, midpoint]. We then set     *</span>
<span class="cm">             *  the midpoint to be closer to left.                            */</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">                </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  After n iterations, we are at most |b - a| / 2^n from the         *</span>
<span class="cm">         *  root of the function. 1 / 2^n goes to zero very quickly,          *</span>
<span class="cm">         *  meaning the convergence is very quick.                            */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/*  End of root.                                                          */</span>

<span class="w">    </span><span class="cm">/*  Main routine used for testing our Bisection implementation.           */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.        */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3.0</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4.0</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159...,        *</span>
<span class="cm">         *  accurate to about 16 decimals.                                    */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Root</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">Sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;pi = {pi}&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="pas">Pas<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">(******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General Public*</span>
<span class="cm"> *  License as published by the Free Software Foundation, either version 3 of *</span>
<span class="cm"> *  the License, or (at your option) any later version.                       *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that it  *</span>
<span class="cm"> *  will be useful but WITHOUT ANY WARRANTY; without even the implied warranty*</span>
<span class="cm"> *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *</span>
<span class="cm"> *  GNU General Public License for more details.                              *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples.  If not, see            *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Computes roots using the bisection method.                            *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/04/17                                                        *</span>
<span class="cm"> ******************************************************************************)</span>
<span class="k">PROGRAM</span><span class="w"> </span><span class="n">Bisection</span><span class="o">;</span>

<span class="cm">(*  We define two constants: The allowed tolerance (or epsilon value),        *</span>
<span class="cm"> *  and the maximum number of iterations we allow for the bisection method.   *)</span>
<span class="k">CONST</span>

<span class="w">    </span><span class="cm">(*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 *)</span>
<span class="w">    </span><span class="n">MaximumNumberOfIterations</span><span class="o">:</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Maximum allowed error. This is double precision epsilon.              *)</span>
<span class="w">    </span><span class="n">Epsilon</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Pi is between 2 and 4 and is a root to sine.                          *)</span>
<span class="w">    </span><span class="n">LeftValue</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">;</span>
<span class="w">    </span><span class="n">RightValue</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="o">;</span>

<span class="cm">(*  Create an alias for real functions f: R -&gt; R. This makes the syntax of    *</span>
<span class="cm"> *  the parameters for the BisectionMethod function a little more readable.   *)</span>
<span class="k">TYPE</span>
<span class="w">    </span><span class="n">RealFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">Function</span><span class="p">(</span><span class="k">Const</span><span class="w"> </span><span class="n">X</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="cm">(*  The main program only has one variable, pi computed via bisection.        *)</span>
<span class="k">VAR</span>
<span class="w">    </span><span class="n">PiByBisection</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="cm">(*  Sin is a built-in procedure. Create a function Real -&gt; Real that computes *</span>
<span class="cm"> *  sin(x) so that we may pass it as a parameter to BisectionMethod.          *)</span>
<span class="k">Function</span><span class="w"> </span><span class="nf">Sine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>
<span class="k">BEGIN</span>
<span class="w">    </span><span class="n">Sine</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">SIN</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">;</span>
<span class="k">END</span><span class="o">;</span>

<span class="cm">(******************************************************************************</span>
<span class="cm"> *  Function:                                                                 *</span>
<span class="cm"> *      BisectionMethod                                                       *</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Computes roots using the bisection method.                            *</span>
<span class="cm"> *   Arguments:                                                               *</span>
<span class="cm"> *       F (RealFunc):                                                        *</span>
<span class="cm"> *           A function from [A, B] to the real numbers.                      *</span>
<span class="cm"> *       A (Real):                                                            *</span>
<span class="cm"> *           One of the endpoints for the interval.                           *</span>
<span class="cm"> *       B (Real):                                                            *</span>
<span class="cm"> *           The other the endpoint for the interval.                         *</span>
<span class="cm"> *   OUTPUT:                                                                  *</span>
<span class="cm"> *       Root (Real):                                                         *</span>
<span class="cm"> *           A root for F between A and B.                                    *</span>
<span class="cm"> ******************************************************************************)</span>
<span class="k">Function</span><span class="w"> </span><span class="nf">BisectionMethod</span><span class="p">(</span><span class="k">Const</span><span class="w"> </span><span class="n">F</span><span class="o">:</span><span class="w"> </span><span class="n">RealFunc</span><span class="o">;</span><span class="w"> </span><span class="k">Const</span><span class="w"> </span><span class="n">A</span><span class="o">,</span><span class="w"> </span><span class="n">B</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="k">VAR</span>
<span class="w">    </span><span class="cm">(*  We do not require A &lt; B, nor F(A) &lt; F(B). We will use Left and Right  *</span>
<span class="cm">     *  to re-orient the interval so that F(Left) &lt; F(Right). Midpoint will   *</span>
<span class="cm">     *  be the center of the interval, and these three values will be updated *</span>
<span class="cm">     *  iteratively as we perform the bisection method.                       *)</span>
<span class="w">    </span><span class="n">Left</span><span class="o">,</span><span class="w"> </span><span class="n">Right</span><span class="o">,</span><span class="w"> </span><span class="n">Midpoint</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Variables for the evaluation of F at A, B, and Midpoint, respectively.*)</span>
<span class="w">    </span><span class="n">AEval</span><span class="o">,</span><span class="w"> </span><span class="n">BEval</span><span class="o">,</span><span class="w"> </span><span class="n">Eval</span><span class="o">:</span><span class="w"> </span><span class="kt">Real</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Dummy variable for tracking how many iterations we&#39;ve performed.      *)</span>
<span class="w">    </span><span class="n">Iters</span><span class="o">:</span><span class="w"> </span><span class="kt">Integer</span><span class="o">;</span>

<span class="k">LABEL</span>
<span class="w">    </span><span class="cm">(*  Several spots allow for early returns in the function. We use a       *</span>
<span class="cm">     *  single label for GOTO to allow us to break out of the function.       *)</span>
<span class="w">    </span><span class="nl">Finished</span><span class="o">;</span>

<span class="k">BEGIN</span>

<span class="w">    </span><span class="cm">(*  Initial setup, find out which evaluation is positive and which is     *</span>
<span class="cm">     *  negative. If the signs of the two agree we treat this as an error.    *)</span>
<span class="w">    </span><span class="n">AEval</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">;</span>
<span class="w">    </span><span class="n">BEval</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Special case, A is a root. Set the output to A and return.            *)</span>
<span class="w">    </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">AEval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Epsilon</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">    </span><span class="k">BEGIN</span>
<span class="w">        </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">A</span><span class="o">;</span>
<span class="w">        </span><span class="k">GOTO</span><span class="w"> </span><span class="nl">Finished</span><span class="o">;</span>
<span class="w">    </span><span class="k">END</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Similarly for B, if F(B) ~= 0, return B.                              *)</span>
<span class="w">    </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">BEval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Epsilon</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">    </span><span class="k">BEGIN</span>
<span class="w">        </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">B</span><span class="o">;</span>
<span class="w">        </span><span class="k">GOTO</span><span class="w"> </span><span class="nl">Finished</span><span class="o">;</span>
<span class="w">    </span><span class="k">END</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  If F(A) &lt; 0 &lt; F(B), then Left = A and Right = B.                      *)</span>
<span class="w">    </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="n">AEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BEval</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">    </span><span class="k">BEGIN</span>

<span class="w">        </span><span class="cm">(*  If F(A) and F(B) have the same sign (both positive or</span>
<span class="cm">         *  both negative), return NaN. Bisection is undefined.               *)</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">((</span><span class="n">AEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="p">(</span><span class="n">BEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">        </span><span class="k">BEGIN</span>
<span class="w">            </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="o">;</span>
<span class="w">            </span><span class="k">GOTO</span><span class="w"> </span><span class="nl">Finished</span><span class="o">;</span>
<span class="w">        </span><span class="k">END</span><span class="o">;</span>

<span class="w">        </span><span class="n">Left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">A</span><span class="o">;</span>
<span class="w">        </span><span class="n">Right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">B</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  If F(B) &lt; 0 &lt; F(A), then Left = B and Right = A.                      *)</span>
<span class="w">    </span><span class="k">END</span>
<span class="w">    </span><span class="k">ELSE</span>
<span class="w">    </span><span class="k">BEGIN</span>

<span class="w">        </span><span class="cm">(*  Same sanity check as before, make sure the signs are different.   *)</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">((</span><span class="n">AEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="p">(</span><span class="n">BEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">        </span><span class="k">BEGIN</span>
<span class="w">            </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="o">;</span>
<span class="w">            </span><span class="k">GOTO</span><span class="w"> </span><span class="nl">Finished</span><span class="o">;</span>
<span class="w">        </span><span class="k">END</span><span class="o">;</span>

<span class="w">        </span><span class="n">Left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">B</span><span class="o">;</span>
<span class="w">        </span><span class="n">Right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">A</span><span class="o">;</span>
<span class="w">    </span><span class="k">END</span><span class="o">;</span>

<span class="w">    </span><span class="n">Midpoint</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Iteratively perform the bisection method.                             *)</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="n">Iters</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="n">MaximumNumberOfIterations</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">DO</span>
<span class="w">    </span><span class="k">BEGIN</span>

<span class="w">        </span><span class="cm">(*  The interval is cut in half based on the sign of F(Midpoint).     *</span>
<span class="cm">         *  Compute this and compare.                                         *)</span>
<span class="w">        </span><span class="n">Eval</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">Midpoint</span><span class="p">)</span><span class="o">;</span>

<span class="w">        </span><span class="cm">(*  If MIDPOINT is close to a root we can exit the function.          *)</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">Eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Epsilon</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="k">BREAK</span><span class="o">;</span>

<span class="w">        </span><span class="cm">(*  Otherwise, divide the range in half. If Eval is negative we       *</span>
<span class="cm">         *  replace Left with Midpoint and move Midpoint closer to Right.     *)</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="n">Eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="k">BEGIN</span>
<span class="w">            </span><span class="n">Left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Midpoint</span><span class="o">;</span>
<span class="w">            </span><span class="n">Midpoint</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Right</span><span class="p">)</span><span class="o">;</span>

<span class="w">        </span><span class="cm">(*  Likewise, if Eval is positive, replace Right with Midpoint and    *</span>
<span class="cm">         *  move Midpoint closer to Left.                                     *)</span>
<span class="w">        </span><span class="k">END</span><span class="w"> </span><span class="k">ELSE</span><span class="w"> </span><span class="k">BEGIN</span>
<span class="w">            </span><span class="n">Right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Midpoint</span><span class="o">;</span>
<span class="w">            </span><span class="n">Midpoint</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Midpoint</span><span class="p">)</span><span class="o">;</span>
<span class="w">        </span><span class="k">END</span><span class="o">;</span>
<span class="w">    </span><span class="k">END</span><span class="o">;</span>

<span class="w">    </span><span class="cm">(*  Provided |B - A| is not too big, we should now have a very good       *</span>
<span class="cm">     *  approximation to the root.                                            *)</span>
<span class="w">    </span><span class="n">BisectionMethod</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Midpoint</span><span class="o">;</span>

<span class="w">    </span><span class="nl">Finished</span><span class="o">:</span>
<span class="k">END</span><span class="o">;</span>

<span class="cm">(*  Program for testing our implementation of the bisection method.           *)</span>
<span class="k">BEGIN</span>

<span class="w">    </span><span class="cm">(*  Pi is between 2 and 4 and is a root to sine.                          *)</span>
<span class="w">    </span><span class="n">PiByBisection</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">BisectionMethod</span><span class="p">(</span><span class="o">@</span><span class="n">Sine</span><span class="o">,</span><span class="w"> </span><span class="n">LeftValue</span><span class="o">,</span><span class="w"> </span><span class="n">RightValue</span><span class="p">)</span><span class="o">;</span>
<span class="w">    </span><span class="nb">WriteLn</span><span class="p">(</span><span class="s">&#39;pi = &#39;</span><span class="o">,</span><span class="w"> </span><span class="n">PiByBisection</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">16</span><span class="p">)</span><span class="o">;</span>

<span class="k">END</span><span class="o">.</span>
</pre></div>

<h2 id="ts">Ts<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using bisection.                    *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/05/18                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Type for a function of the form f: R -&gt; R.                                */</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">realfunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>

<span class="cm">/*  Computes the root of a function using the bisection method.               */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">bisectionMethod</span><span class="p">(</span><span class="nx">f</span><span class="o">:</span><span class="w"> </span><span class="kt">realfunc</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">64</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Getting exact roots is hard using floating-point numbers. Allow a     *</span>
<span class="cm">     *  tolerance in our computation. This value is double precision epsilon. */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">EPSILON</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The midpoint for the bisection method. This will update as we iterate.*/</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">midpoint</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of the number of iterations performed.     */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">iters</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  We do not require a &lt; b, nor do we require f(a) &lt; f(b). We only need  *</span>
<span class="cm">     *  one of these to evaluate to a negative under f and one to evaluate to *</span>
<span class="cm">     *  positive. We will call the negative entry left and positive one right.*/</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">left</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">right</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Evaluate f at the two endpoints to determine which is positive and    *</span>
<span class="cm">     *  which is negative. We transform [a, b] to [left, right] by doing this.*/</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">A_EVAL</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">B_EVAL</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.                   */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">A_EVAL</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Similarly, if f(b) = 0, then we have already found the root. Return b.*/</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">B_EVAL</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Compare the two evaluations and set left and right accordingly.       */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">A_EVAL</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">B_EVAL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If both evaluations are negative, or if both are positive, then   *</span>
<span class="cm">         *  the bisection method will not work. Return NaN.                   */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">B_EVAL</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="nx">A_EVAL</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.         */</span>
<span class="w">        </span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">a</span><span class="p">;</span>
<span class="w">        </span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  In this case the function starts positive and tends to a negative.    */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be         *</span>
<span class="cm">         *  negative and one to be positive. Abort if both have the same sign.*/</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">A_EVAL</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="nx">B_EVAL</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                    */</span>
<span class="w">        </span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
<span class="w">        </span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.          */</span>
<span class="w">    </span><span class="nx">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Iteratively divide the range in half to find the root.                */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="nx">iters</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If f(x) is very small, we are close to a root and can break out   *</span>
<span class="cm">         *  of this for loop. Check for this.                                 */</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">EVAL</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">midpoint</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">EVAL</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Apply bisection to get a better approximation for the root. We    *</span>
<span class="cm">         *  have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the      *</span>
<span class="cm">         *  interval [left, right] with [midpoint, right]. Set left to the    *</span>
<span class="cm">         *  midpoint and reset the midpoint to be closer to right.            */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">EVAL</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="nx">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">right</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  In the other case, f(midpoint) &gt; 0, we replace right with the     *</span>
<span class="cm">         *  midpoint, changing [left, right] into [left, midpoint]. We then   *</span>
<span class="cm">         *  set the midpoint to be closer to left.                            */</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="nx">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  After n iterations, we are no more than |b - a| / 2^n away from the   *</span>
<span class="cm">     *  root of the function. 1 / 2^n goes to zero very quickly, meaning the  *</span>
<span class="cm">     *  convergence is very quick.                                            */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of bisectionMethod.                                                   */</span>

<span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.                */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">A</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">B</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate       *</span>
<span class="cm"> *  to about 16 decimals.                                                     */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">PI</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">bisectionMethod</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">,</span><span class="w"> </span><span class="nx">A</span><span class="p">,</span><span class="w"> </span><span class="nx">B</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">OUTPUT</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;pi = &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">PI</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mf">16</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">OUTPUT</span><span class="p">);</span>
</pre></div>

<h2 id="jl">Jl<br /></h2>
<div class="highlight"><pre><span></span><span class="c">################################################################################</span>
<span class="c">#                                   LICENSE                                    #</span>
<span class="c">################################################################################</span>
<span class="c">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="c">#   redistribute it and/or modify it under the terms of the GNU General Public #</span>
<span class="c">#   License as published by the Free Software Foundation, either version 3 of  #</span>
<span class="c">#   the License, or (at your option) any later version.                        #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is distributed in the hope that it   #</span>
<span class="c">#   will be useful, but WITHOUT ANY WARRANTY; without even the implied         #</span>
<span class="c">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  #</span>
<span class="c">#   GNU General Public License for more details.                               #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   You should have received a copy of the GNU General Public License          #</span>
<span class="c">#   along with mitx_mathematics_programming_examples.  If not, see             #</span>
<span class="c">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="c">################################################################################</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Calculates roots of a function using bisection.                        #</span>
<span class="c">################################################################################</span>
<span class="c">#   Author:     Ryan Maguire                                                   #</span>
<span class="c">#   Date:       March 29, 2025.                                                #</span>
<span class="c">################################################################################</span>

<span class="c">################################################################################</span>
<span class="c">#   Function:                                                                  #</span>
<span class="c">#       bisection                                                              #</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Computes the root of a function f between a and b.                     #</span>
<span class="c">#   Arguments:                                                                 #</span>
<span class="c">#       f (function):                                                          #</span>
<span class="c">#           A function f: R -&gt; R. The root of f is computed.                   #</span>
<span class="c">#       a (real):                                                              #</span>
<span class="c">#           One of the endpoints of the interval for f.                        #</span>
<span class="c">#       b (real):                                                              #</span>
<span class="c">#           The other endpoint for f.                                          #</span>
<span class="c">#   Output:                                                                    #</span>
<span class="c">#       root (real):                                                           #</span>
<span class="c">#           A root of the function f between a and b.                          #</span>
<span class="c">################################################################################</span>
<span class="k">function</span><span class="w"> </span><span class="n">bisection</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Tell the algorithm to stop after several iterations to avoid an</span>
<span class="w">    </span><span class="c"># infinite loop. Double precision numbers have 52 bits in the mantissa,</span>
<span class="w">    </span><span class="c"># so if |b - a| ~= 1, after 52 iterations of bisection we will get as</span>
<span class="w">    </span><span class="c"># close as we can to the root. To allow for |b - a| to be larger, halt</span>
<span class="w">    </span><span class="c"># the algorithm after at most 64 steps.</span>
<span class="w">    </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span>

<span class="w">    </span><span class="c"># The maximum allowed error. This is double precision epsilon.</span>
<span class="w">    </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span>

<span class="w">    </span><span class="c"># Evaluate f at the two endpoints to determine which is positive and</span>
<span class="w">    </span><span class="c"># which is negative. We transform [a, b] to [left, right] by doing this.</span>
<span class="w">    </span><span class="n">a_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="w">    </span><span class="n">b_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Rare case, f(a) = 0. Return a, no bisection needed.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># Similarly, if f(b) = 0, then we have already found the root. Return b.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># Compare the two evaluations and set left and right accordingly.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b_eval</span>

<span class="w">        </span><span class="c"># If both evaluations are negative, or if both are positive, then</span>
<span class="w">        </span><span class="c"># the bisection method will not work. Return NaN.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c"># Otherwise, since f(a) &lt; f(b), set left = a and right = b.</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span>

<span class="w">    </span><span class="c"># In this case the function starts positive and tends to a negative.</span>
<span class="w">    </span><span class="k">else</span>

<span class="w">        </span><span class="c"># Same sanity check as before. We need one evaluation to be</span>
<span class="w">        </span><span class="c"># negative and one to be positive. Abort if both have the same sign.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c"># Since f(a) &gt; f(b), set left = b and right = a.</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># Start the bisection method. Compute the midpoint of a and b.</span>
<span class="w">    </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>

<span class="w">    </span><span class="c"># Iteratively apply the bisection method.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">maximum_number_of_iterations</span>

<span class="w">        </span><span class="c"># If f(x) is very small, we are close to a root and can break out</span>
<span class="w">        </span><span class="c"># of this for loop. Check for this.</span>
<span class="w">        </span><span class="n">eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c"># Apply bisection to get a better approximation for the root. We</span>
<span class="w">        </span><span class="c"># have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the</span>
<span class="w">        </span><span class="c"># interval [left, right] with [midpoint, right]. Set left to the</span>
<span class="w">        </span><span class="c"># midpoint and reset the midpoint to be closer to right.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">)</span>

<span class="w">        </span><span class="c"># In the other case, f(midpoint) &gt; 0, we replace right with the</span>
<span class="w">        </span><span class="c"># midpoint, changing [left, right] into [left, midpoint]. We then</span>
<span class="w">        </span><span class="c"># set the midpoint to be closer to left.</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">)</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># After n iterations, we are no more than |b - a| / 2^n away from the</span>
<span class="w">    </span><span class="c"># root of the function. 1 / 2^n goes to zero very quickly, meaning the</span>
<span class="w">    </span><span class="c"># convergence is very quick.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span>

<span class="k">end</span>

<span class="c"># pi is somewhere between 3 and 4, and it is a root to sine.</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span>

<span class="c"># Compute pi using bisection. We should get pi = 3.14159..., accurate</span>
<span class="c"># to about 16 decimals.</span>
<span class="n">pi_by_bisection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bisection</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;pi = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi_by_bisection</span><span class="p">)</span>
</pre></div>

<h2 id="go">Go<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using bisection.                    *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/28                                                        *</span>
<span class="cm"> ******************************************************************************/</span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="cm">/*  Only standard library imports are needed.                                 */</span>
<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span><span class="w">   </span><span class="cm">/*  Printf provided here, used for printing text to the screen.   */</span>
<span class="w">    </span><span class="s">&quot;math&quot;</span><span class="w">  </span><span class="cm">/*  Abs, floating-point absolute value function, found here.      */</span>
<span class="p">)</span>

<span class="cm">/*  Function pointer notation is a little confusing. Create a typedef for it  *</span>
<span class="cm"> *  so we do not need to explicitly use it later.                             */</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">realfunc</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="kt">float64</span><span class="p">)</span><span class="w"> </span><span class="kt">float64</span>

<span class="cm">/*  Computes the root of a function using the bisection method.               */</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">bisection_method</span><span class="p">(</span><span class="nx">f</span><span class="w"> </span><span class="nx">realfunc</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="kt">float64</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">float64</span><span class="p">)</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">maximum_number_of_iterations</span><span class="w"> </span><span class="kt">uint32</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">64</span>

<span class="w">    </span><span class="cm">/*  Getting exact roots is hard using floating-point numbers. Allow a     *</span>
<span class="cm">     *  tolerance in our computation. This value is double precision epsilon. */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">epsilon</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of how many iterations we have performed.  */</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="kt">uint32</span>

<span class="w">    </span><span class="cm">/*  The midpoint for the bisection method. This will update as we iterate.*/</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">midpoint</span><span class="w"> </span><span class="kt">float64</span>

<span class="w">    </span><span class="cm">/*  We do not require a &lt; b, nor do we require f(a) &lt; f(b). We only need  *</span>
<span class="cm">     *  one of these to evaluate to a negative under f and one to evaluate to *</span>
<span class="cm">     *  positive. We will call the negative entry left and positive one right.*/</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="kt">float64</span>

<span class="w">    </span><span class="cm">/*  Evaluate f at the two endpoints to determine which is positive and    *</span>
<span class="cm">     *  which is negative. We transform [a, b] to [left, right] by doing this.*/</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">a_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">b_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>

<span class="w">    </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.                   */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">a_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">a</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Similarly, if f(b) = 0, then we have already found the root. Return b.*/</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">b_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">b</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Compare the two evaluations and set left and right accordingly.       */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">a_eval</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">b_eval</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If both evaluations are negative, or if both are positive, then   *</span>
<span class="cm">         *  the bisection method will not work. Return NaN.                   */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">b_eval</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">a_eval</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.         */</span>
<span class="w">        </span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">a</span>
<span class="w">        </span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">b</span>

<span class="w">    </span><span class="cm">/*  In this case the function starts positive and tends to a negative.    */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be         *</span>
<span class="cm">         *  negative and one to be positive. Abort if both have the same sign.*/</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">a_eval</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">b_eval</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                    */</span>
<span class="w">        </span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">b</span>
<span class="w">        </span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">a</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.          */</span>
<span class="w">    </span><span class="nx">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span>

<span class="w">    </span><span class="cm">/*  Iteratively divide the range in half to find the root.                */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If f(x) is very small, we are close to a root and can break out   *</span>
<span class="cm">         *  of this for loop. Check for this.                                 */</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">midpoint</span><span class="p">)</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">math</span><span class="p">.</span><span class="nx">Abs</span><span class="p">(</span><span class="nx">eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">epsilon</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Apply bisection to get a better approximation for the root. We    *</span>
<span class="cm">         *  have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the      *</span>
<span class="cm">         *  interval [left, right] with [midpoint, right]. Set left to the    *</span>
<span class="cm">         *  midpoint and reset the midpoint to be closer to right.            */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">eval</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">midpoint</span>
<span class="w">            </span><span class="nx">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">right</span><span class="p">)</span>

<span class="w">        </span><span class="cm">/*  In the other case, f(midpoint) &gt; 0, we replace right with the     *</span>
<span class="cm">         *  midpoint, changing [left, right] into [left, midpoint]. We then   *</span>
<span class="cm">         *  set the midpoint to be closer to left.                            */</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">midpoint</span>
<span class="w">            </span><span class="nx">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  After n iterations, we are no more than |b - a| / 2^n away from the   *</span>
<span class="cm">     *  root of the function. 1 / 2^n goes to zero very quickly, meaning the  *</span>
<span class="cm">     *  convergence is very quick.                                            */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">midpoint</span>
<span class="p">}</span>
<span class="cm">/*  End of bisection_method.                                                  */</span>

<span class="cm">/*  Main routine used for testing our implementation of the bisection method. */</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.            */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">3.0</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">4.0</span>

<span class="w">    </span><span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate   *</span>
<span class="cm">     *  to about 16 decimals.                                                 */</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">bisection_method</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;pi = %.16f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">pi</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h2 id="r">R<br /></h2>
<div class="highlight"><pre><span></span><span class="c">################################################################################</span>
<span class="c">#                                   LICENSE                                    #</span>
<span class="c">################################################################################</span>
<span class="c">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="c">#   redistribute it and/or modify it under the terms of the GNU General Public #</span>
<span class="c">#   License as published by the Free Software Foundation, either version 3 of  #</span>
<span class="c">#   the License, or (at your option) any later version.                        #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   mitx_mathematics_programming_examples is distributed in the hope that it   #</span>
<span class="c">#   will be useful, but WITHOUT ANY WARRANTY; without even the implied         #</span>
<span class="c">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  #</span>
<span class="c">#   GNU General Public License for more details.                               #</span>
<span class="c">#                                                                              #</span>
<span class="c">#   You should have received a copy of the GNU General Public License          #</span>
<span class="c">#   along with mitx_mathematics_programming_examples.  If not, see             #</span>
<span class="c">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="c">################################################################################</span>
<span class="c">#   Purpose:                                                                   #</span>
<span class="c">#       Calculates roots of a function using bisection.                        #</span>
<span class="c">################################################################################</span>
<span class="c">#   Author:     Ryan Maguire                                                   #</span>
<span class="c">#   Date:       May 18, 2025.                                                  #</span>
<span class="c">################################################################################</span>

<span class="c"># Computes the root of a function via bisection.</span>
<span class="c">bisection &lt;- function(f, a, b) {</span>

<span class="c">    # Tell the algorithm to stop after several iterations to avoid an</span>
<span class="c">    # infinite loop. Double precision numbers have 52 bits in the mantissa,</span>
<span class="c">    # so if |b - a| ~= 1, after 52 iterations of bisection we will get as</span>
<span class="c">    # close as we can to the root. To allow for |b - a| to be larger, halt</span>
<span class="c">    # the algorithm after at most 64 steps.</span>
<span class="c">    maximum_number_of_iterations &lt;- 64</span>

<span class="c">    # The maximum allowed error. This is double precision epsilon.</span>
<span class="c">    epsilon &lt;- 2.220446049250313E-16</span>

<span class="c">    # Evaluate f at the two endpoints to determine which is positive and</span>
<span class="c">    # which is negative. We transform [a, b] to [left, right] by doing this.</span>
<span class="c">    a_eval &lt;- f(a)</span>
<span class="c">    b_eval &lt;- f(b)</span>

<span class="c">    # Rare case, f(a) = 0. Return a, no bisection needed.</span>
<span class="c">    if (a_eval == 0.0) {</span>
<span class="c">        return(a)</span>
<span class="c">    }</span>

<span class="c">    # Similarly, if f(b) = 0, then we have already found the root. Return b.</span>
<span class="c">    if (b_eval == 0.0) {</span>
<span class="c">        return(b)</span>
<span class="c">    }</span>

<span class="c">    # Compare the two evaluations and set left and right accordingly.</span>
<span class="c">    if (a_eval &lt; b_eval) {</span>

<span class="c">        # If both evaluations are negative, or if both are positive, then</span>
<span class="c">        # the bisection method will not work. Return NaN.</span>
<span class="c">        if ((b_eval &lt; 0.0) || (a_eval &gt; 0.0)) {</span>
<span class="c">            return((a - a) / (a - a))</span>
<span class="c">        }</span>

<span class="c">        # Otherwise, since f(a) &lt; f(b), set left = a and right = b.</span>
<span class="c">        left &lt;- a</span>
<span class="c">        right &lt;- b</span>

<span class="c">    # In this case the function starts positive and tends to a negative.</span>
<span class="c">    } else {</span>

<span class="c">        # Same sanity check as before. We need one evaluation to be</span>
<span class="c">        # negative and one to be positive. Abort if both have the same sign.</span>
<span class="c">        if ((a_eval &lt; 0.0) || (b_eval &gt; 0.0)) {</span>
<span class="c">            return((a - a) / (a - a))</span>
<span class="c">        }</span>

<span class="c">        # Since f(a) &gt; f(b), set left = b and right = a.</span>
<span class="c">        left &lt;- b</span>
<span class="c">        right &lt;- a</span>
<span class="c">    }</span>

<span class="c">    # Start the bisection method. Compute the midpoint of a and b.</span>
<span class="c">    midpoint &lt;- 0.5 * (a + b)</span>

<span class="c">    # Iteratively apply the bisection method.</span>
<span class="c">    for (iters in 1:maximum_number_of_iterations) {</span>

<span class="c">        # If f(x) is very small, we are close to a root and can break out</span>
<span class="c">        # of this for loop. Check for this.</span>
<span class="c">        f_eval &lt;- f(midpoint)</span>

<span class="c">        if (abs(f_eval) &lt;= epsilon) {</span>
<span class="c">            break</span>
<span class="c">        }</span>

<span class="c">        # Apply bisection to get a better approximation for the root. We</span>
<span class="c">        # have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the</span>
<span class="c">        # interval [left, right] with [midpoint, right]. Set left to the</span>
<span class="c">        # midpoint and reset the midpoint to be closer to right.</span>
<span class="c">        if (f_eval &lt; 0.0) {</span>
<span class="c">            left &lt;- midpoint</span>
<span class="c">            midpoint &lt;- 0.5 * (midpoint + right)</span>

<span class="c">        # In the other case, f(midpoint) &gt; 0, we replace right with the</span>
<span class="c">        # midpoint, changing [left, right] into [left, midpoint]. We then</span>
<span class="c">        # set the midpoint to be closer to left.</span>
<span class="c">        } else {</span>
<span class="c">            right &lt;- midpoint</span>
<span class="c">            midpoint &lt;- 0.5 * (left + midpoint)</span>
<span class="c">        }</span>
<span class="c">    }</span>

<span class="c">    # After n iterations, we are no more than |b - a| / 2^n away from the</span>
<span class="c">    # root of the function. 1 / 2^n goes to zero very quickly, meaning the</span>
<span class="c">    # convergence is very quick.</span>
<span class="c">    return(midpoint)</span>
<span class="c">}</span>

<span class="c"># pi is somewhere between 3 and 4, and it is a root to sine.</span>
<span class="c">A &lt;- 3.0</span>
<span class="c">B &lt;- 4.0</span>

<span class="c"># Compute pi using bisection. We should get pi = 3.14159..., accurate</span>
<span class="c"># to about 16 decimals.</span>
<span class="c">pi_by_bisection &lt;- bisection(sin, A, B)</span>
<span class="c">output = sprintf(&quot;pi = %.16f&quot;, pi_by_bisection)</span>
<span class="c">message(output)</span>
</pre></div>

<h2 id="rs">Rs<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using bisection.                    *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/04/17                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Function pointer notation is a little confusing. Create a typedef for it  *</span>
<span class="cm"> *  so we do not need to explicitly use it later.                             */</span>
<span class="k">type</span> <span class="nc">RealFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span><span class="p">;</span>

<span class="cm">/*  Computes the root of a function using the bisection method.               */</span>
<span class="k">fn</span> <span class="nf">bisection_method</span><span class="p">(</span><span class="n">f</span>: <span class="nc">RealFunc</span><span class="p">,</span><span class="w"> </span><span class="n">a</span>: <span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">f64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Getting exact roots is hard using floating-point numbers. Allow a     *</span>
<span class="cm">     *  tolerance in our computation. This value is double precision epsilon. */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">EPSILON</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The midpoint for the bisection method. This will update as we iterate.*/</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">midpoint</span>: <span class="kt">f64</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  We do not require a &lt; b, nor do we require f(a) &lt; f(b). We only need  *</span>
<span class="cm">     *  one of these to evaluate to a negative under f and one to evaluate to *</span>
<span class="cm">     *  positive. We will call the negative entry left and positive one right.*/</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">left</span>: <span class="kt">f64</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">right</span>: <span class="kt">f64</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Evaluate f at the two endpoints to determine which is positive and    *</span>
<span class="cm">     *  which is negative. We transform [a, b] to [left, right] by doing this.*/</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a_eval</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b_eval</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.                   */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Similarly, if f(b) = 0, then we have already found the root. Return b.*/</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Compare the two evaluations and set left and right accordingly.       */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If both evaluations are negative, or if both are positive, then   *</span>
<span class="cm">         *  the bisection method will not work. Return NaN.                   */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.         */</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  In this case the function starts positive and tends to a negative.    */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be         *</span>
<span class="cm">         *  negative and one to be positive. Abort if both have the same sign.*/</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                    */</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.          */</span>
<span class="w">    </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Iteratively divide the range in half to find the root.                */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If f(x) is very small, we are close to a root and can break out   *</span>
<span class="cm">         *  of this for loop. Check for this.                                 */</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">eval</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">eval</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">EPSILON</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Apply bisection to get a better approximation for the root. We    *</span>
<span class="cm">         *  have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the      *</span>
<span class="cm">         *  interval [left, right] with [midpoint, right]. Set left to the    *</span>
<span class="cm">         *  midpoint and reset the midpoint to be closer to right.            */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  In the other case, f(midpoint) &gt; 0, we replace right with the     *</span>
<span class="cm">         *  midpoint, changing [left, right] into [left, midpoint]. We then   *</span>
<span class="cm">         *  set the midpoint to be closer to left.                            */</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  After n iterations, we are no more than |b - a| / 2^n away from the   *</span>
<span class="cm">     *  root of the function. 1 / 2^n goes to zero very quickly, meaning the  *</span>
<span class="cm">     *  convergence is very quick.                                            */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of bisection_method.                                                  */</span>

<span class="cm">/*  Main routine used for testing our implementation of the bisection method. */</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.            */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">A</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">B</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate   *</span>
<span class="cm">     *  to about 16 decimals.                                                 */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pi</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="n">bisection_method</span><span class="p">(</span><span class="kt">f64</span>::<span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;pi( = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h2 id="pro">Pro<br /></h2>
<div class="highlight"><pre><span></span><span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="p">;</span>                                   <span class="nv">LICENSE</span>                                    <span class="p">;</span>
<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="p">;</span>   <span class="nv">This</span> <span class="s s-Atom">file</span> <span class="o">is</span> <span class="s s-Atom">part</span> <span class="s s-Atom">of</span> <span class="s s-Atom">mitx_mathematics_programming_examples</span><span class="p">.</span>                <span class="p">;</span>
<span class="p">;</span>                                                                              <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">mitx_mathematics_programming_examples</span> <span class="o">is</span> <span class="s s-Atom">free</span> <span class="nn">software</span><span class="p">:</span> <span class="s s-Atom">you</span> <span class="s s-Atom">can</span>            <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">redistribute</span> <span class="s s-Atom">it</span> <span class="s s-Atom">and</span><span class="o">/</span><span class="s s-Atom">or</span> <span class="s s-Atom">modify</span> <span class="s s-Atom">it</span> <span class="s s-Atom">under</span> <span class="s s-Atom">the</span> <span class="s s-Atom">terms</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span> <span class="nv">GNU</span> <span class="nv">General</span> <span class="nv">Public</span> <span class="p">;</span>
<span class="p">;</span>   <span class="nv">License</span> <span class="s s-Atom">as</span> <span class="s s-Atom">published</span> <span class="s s-Atom">by</span> <span class="s s-Atom">the</span> <span class="nv">Free</span> <span class="nv">Software</span> <span class="nv">Foundation</span><span class="p">,</span> <span class="s s-Atom">either</span> <span class="s s-Atom">version</span> <span class="mi">3</span> <span class="s s-Atom">of</span>  <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">the</span> <span class="nv">License</span><span class="p">,</span> <span class="nf">or</span> <span class="p">(</span><span class="s s-Atom">at</span> <span class="s s-Atom">your</span> <span class="s s-Atom">option</span><span class="p">)</span> <span class="s s-Atom">any</span> <span class="s s-Atom">later</span> <span class="s s-Atom">version</span><span class="p">.</span>                        <span class="p">;</span>
<span class="p">;</span>                                                                              <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">mitx_mathematics_programming_examples</span> <span class="o">is</span> <span class="s s-Atom">distributed</span> <span class="s s-Atom">in</span> <span class="s s-Atom">the</span> <span class="s s-Atom">hope</span> <span class="s s-Atom">that</span> <span class="s s-Atom">it</span>   <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">will</span> <span class="s s-Atom">be</span> <span class="s s-Atom">useful</span> <span class="s s-Atom">but</span> <span class="nv">WITHOUT</span> <span class="nv">ANY</span> <span class="nv">WARRANTY</span><span class="p">;</span> <span class="s s-Atom">without</span> <span class="s s-Atom">even</span> <span class="s s-Atom">the</span> <span class="s s-Atom">implied</span> <span class="s s-Atom">warranty</span> <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">of</span> <span class="nv">MERCHANTABILITY</span> <span class="s s-Atom">or</span> <span class="nv">FITNESS</span> <span class="nv">FOR</span> <span class="nv">A</span> <span class="nv">PARTICULAR</span> <span class="nv">PURPOSE</span><span class="p">.</span>  <span class="nv">See</span> <span class="s s-Atom">the</span>           <span class="p">;</span>
<span class="p">;</span>   <span class="nv">GNU</span> <span class="nv">General</span> <span class="nv">Public</span> <span class="nv">License</span> <span class="s s-Atom">for</span> <span class="s s-Atom">more</span> <span class="s s-Atom">details</span><span class="p">.</span>                               <span class="p">;</span>
<span class="p">;</span>                                                                              <span class="p">;</span>
<span class="p">;</span>   <span class="nv">You</span> <span class="s s-Atom">should</span> <span class="s s-Atom">have</span> <span class="s s-Atom">received</span> <span class="s s-Atom">a</span> <span class="s s-Atom">copy</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span> <span class="nv">GNU</span> <span class="nv">General</span> <span class="nv">Public</span> <span class="nv">License</span>          <span class="p">;</span>
<span class="p">;</span>   <span class="s s-Atom">along</span> <span class="s s-Atom">with</span> <span class="s s-Atom">mitx_mathematics_programming_examples</span><span class="p">.</span>  <span class="nv">If</span> <span class="o">not</span><span class="p">,</span> <span class="s s-Atom">see</span>             <span class="p">;</span>
<span class="p">;</span>   <span class="o">&lt;</span><span class="nn">https</span><span class="p">:</span><span class="o">//</span><span class="s s-Atom">www</span><span class="p">.</span><span class="s s-Atom">gnu</span><span class="p">.</span><span class="s s-Atom">org</span><span class="o">/</span><span class="s s-Atom">licenses/&gt;.</span>                                           <span class="p">;</span>
<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="p">;</span>   <span class="nv">Purpose</span><span class="s s-Atom">:</span>                                                                   <span class="p">;</span>
<span class="p">;</span>       <span class="nv">Calculates</span> <span class="s s-Atom">roots</span> <span class="s s-Atom">using</span> <span class="s s-Atom">the</span> <span class="s s-Atom">bisection</span> <span class="s s-Atom">method</span><span class="p">.</span>                           <span class="p">;</span>
<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="p">;</span>   <span class="nv">Author</span><span class="s s-Atom">:</span> <span class="nv">Ryan</span> <span class="nv">Maguire</span>                                                       <span class="p">;</span>
<span class="p">;</span>   <span class="nv">Date</span><span class="s s-Atom">:</span>   <span class="mi">2025</span><span class="o">/</span><span class="mi">03</span><span class="o">/</span><span class="mi">09</span>                                                         <span class="p">;</span>
<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>

<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="p">;</span>   <span class="nv">Function</span><span class="s s-Atom">:</span>                                                                  <span class="p">;</span>
<span class="p">;</span>       <span class="nv">BISECTION_METHOD</span>                                                       <span class="p">;</span>
<span class="p">;</span>   <span class="nv">Purpose</span><span class="s s-Atom">:</span>                                                                   <span class="p">;</span>
<span class="p">;</span>       <span class="nv">Computes</span> <span class="s s-Atom">roots</span> <span class="s s-Atom">using</span> <span class="s s-Atom">the</span> <span class="s s-Atom">bisection</span> <span class="s s-Atom">method</span><span class="p">.</span>                             <span class="p">;</span>
<span class="p">;</span>   <span class="nv">Arguments</span><span class="s s-Atom">:</span>                                                                 <span class="p">;</span>
<span class="p">;</span>       <span class="nv">FUNC</span> <span class="p">(</span><span class="nv">FUNCTION</span><span class="p">)</span><span class="s s-Atom">:</span>                                                       <span class="p">;</span>
<span class="p">;</span>           <span class="nv">A</span> <span class="s s-Atom">function</span> <span class="s s-Atom">from</span> <span class="p">[</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">]</span> <span class="s s-Atom">to</span> <span class="s s-Atom">the</span> <span class="s s-Atom">real</span> <span class="s s-Atom">numbers</span><span class="p">.</span>                        <span class="p">;</span>
<span class="p">;</span>       <span class="nv">A</span> <span class="p">(</span><span class="nv">REAL</span><span class="p">)</span><span class="s s-Atom">:</span>                                                              <span class="p">;</span>
<span class="p">;</span>           <span class="nv">One</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span> <span class="s s-Atom">endpoints</span> <span class="s s-Atom">for</span> <span class="s s-Atom">the</span> <span class="s s-Atom">interval</span><span class="p">.</span>                             <span class="p">;</span>
<span class="p">;</span>       <span class="nv">B</span> <span class="p">(</span><span class="nv">REAL</span><span class="p">)</span><span class="s s-Atom">:</span>                                                              <span class="p">;</span>
<span class="p">;</span>           <span class="nv">The</span> <span class="s s-Atom">other</span> <span class="s s-Atom">the</span> <span class="s s-Atom">endpoint</span> <span class="s s-Atom">for</span> <span class="s s-Atom">the</span> <span class="s s-Atom">interval</span><span class="p">.</span>                           <span class="p">;</span>
<span class="p">;</span>   <span class="nv">OUTPUT</span><span class="s s-Atom">:</span>                                                                    <span class="p">;</span>
<span class="p">;</span>       <span class="nv">ROOT</span> <span class="p">(</span><span class="nv">REAL</span><span class="p">)</span><span class="s s-Atom">:</span>                                                           <span class="p">;</span>
<span class="p">;</span>           <span class="nv">A</span> <span class="s s-Atom">root</span> <span class="s s-Atom">for</span> <span class="nv">FUNC</span><span class="p">.</span>                                                   <span class="p">;</span>
<span class="p">;</span><span class="s s-Atom">------------------------------------------------------------------------------</span><span class="p">;</span>
<span class="nv">FUNCTION</span> <span class="nv">BISECTION_METHOD</span><span class="p">,</span> <span class="nv">FUNC</span><span class="p">,</span> <span class="nv">A</span><span class="p">,</span> <span class="nv">B</span>

    <span class="p">;</span> <span class="nv">Tells</span> <span class="s s-Atom">the</span> <span class="s s-Atom">compiler</span> <span class="s s-Atom">that</span> <span class="s s-Atom">integers</span> <span class="s s-Atom">should</span> <span class="s s-Atom">be</span> <span class="mi">32</span> <span class="s s-Atom">bits</span><span class="p">,</span> <span class="o">not</span> <span class="mf">16.</span>
    <span class="nv">COMPILE_OPT</span> <span class="nv">IDL2</span>

    <span class="p">;</span> <span class="nv">Error</span> <span class="s s-Atom">checking</span> <span class="s s-Atom">code</span><span class="p">.</span>
    <span class="nv">ON_ERROR</span><span class="p">,</span> <span class="mi">2</span>

    <span class="p">;</span> <span class="nv">Given</span> <span class="s s-Atom">a</span> <span class="s s-Atom">continuous</span> <span class="s s-Atom">function</span> <span class="s s-Atom">defined</span> <span class="s s-Atom">on</span> <span class="p">[</span><span class="s s-Atom">a</span><span class="p">,</span> <span class="s s-Atom">b</span><span class="p">],</span> <span class="s s-Atom">the</span> <span class="s s-Atom">nth</span> <span class="s s-Atom">iteration</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span>
    <span class="p">;</span> <span class="s s-Atom">bisection</span> <span class="s s-Atom">method</span> <span class="o">is</span> <span class="s s-Atom">at</span> <span class="s s-Atom">most</span> <span class="p">|</span><span class="s s-Atom">b</span> <span class="o">-</span> <span class="s s-Atom">a</span><span class="p">|</span> <span class="o">/</span> <span class="mi">2</span><span class="s s-Atom">^n</span> <span class="s s-Atom">away</span> <span class="s s-Atom">from</span> <span class="s s-Atom">the</span> <span class="s s-Atom">root</span><span class="p">.</span> <span class="nv">A</span> <span class="s s-Atom">double</span>
    <span class="p">;</span> <span class="s s-Atom">precision</span> <span class="s s-Atom">number</span> <span class="s s-Atom">has</span> <span class="mi">52</span> <span class="s s-Atom">bits</span> <span class="s s-Atom">in</span> <span class="s s-Atom">the</span> <span class="s s-Atom">mantissa</span><span class="p">,</span> <span class="s s-Atom">meaning</span> <span class="s s-Atom">if</span> <span class="p">|</span><span class="s s-Atom">b</span> <span class="o">-</span> <span class="s s-Atom">a</span><span class="p">|</span> <span class="s s-Atom">~=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">;</span> <span class="s s-Atom">then</span> <span class="s s-Atom">after</span> <span class="mi">52</span> <span class="s s-Atom">iterations</span> <span class="s s-Atom">we</span> <span class="s s-Atom">are</span> <span class="s s-Atom">as</span> <span class="s s-Atom">close</span> <span class="s s-Atom">to</span> <span class="s s-Atom">the</span> <span class="s s-Atom">root</span> <span class="s s-Atom">as</span> <span class="s s-Atom">we</span> <span class="s s-Atom">can</span> <span class="s s-Atom">get</span><span class="p">.</span>
    <span class="p">;</span> <span class="nv">To</span> <span class="s s-Atom">allow</span> <span class="s s-Atom">for</span> <span class="s s-Atom">a</span> <span class="s s-Atom">larger</span> <span class="s s-Atom">range</span><span class="p">,</span> <span class="s s-Atom">halt</span> <span class="s s-Atom">the</span> <span class="s s-Atom">algorithm</span> <span class="s s-Atom">after</span> <span class="mi">64</span> <span class="s s-Atom">iterations</span><span class="p">.</span>
    <span class="nv">MAXIMUM_NUMBER_OF_ITERATIONS</span> <span class="o">=</span> <span class="mi">64</span>

    <span class="p">;</span> <span class="nv">Maximum</span> <span class="s s-Atom">allowed</span> <span class="s s-Atom">error</span><span class="p">.</span> <span class="nv">This</span> <span class="o">is</span> <span class="s s-Atom">double</span> <span class="s s-Atom">precision</span> <span class="s s-Atom">epsilon</span><span class="p">.</span>
    <span class="nv">EPSILON</span> <span class="o">=</span> <span class="mf">2.220446049250313E-16</span>

    <span class="p">;</span> <span class="nv">Initial</span> <span class="s s-Atom">setup</span><span class="p">,</span> <span class="s s-Atom">find</span> <span class="s s-Atom">out</span> <span class="s s-Atom">which</span> <span class="s s-Atom">evaluation</span> <span class="o">is</span> <span class="s s-Atom">positive</span> <span class="s s-Atom">and</span> <span class="s s-Atom">which</span> <span class="o">is</span>
    <span class="p">;</span> <span class="s s-Atom">negative</span><span class="p">.</span> <span class="nv">If</span> <span class="s s-Atom">the</span> <span class="s s-Atom">signs</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span> <span class="s s-Atom">two</span> <span class="s s-Atom">agree</span> <span class="s s-Atom">we</span> <span class="s s-Atom">treat</span> <span class="s s-Atom">this</span> <span class="s s-Atom">as</span> <span class="s s-Atom">an</span> <span class="s s-Atom">error</span><span class="p">.</span>
    <span class="nv">A_EVAL</span> <span class="o">=</span> <span class="nv">CALL_FUNCTION</span><span class="p">(</span><span class="nv">FUNC</span><span class="p">,</span> <span class="nv">A</span><span class="p">)</span>
    <span class="nv">B_EVAL</span> <span class="o">=</span> <span class="nv">CALL_FUNCTION</span><span class="p">(</span><span class="nv">FUNC</span><span class="p">,</span> <span class="nv">B</span><span class="p">)</span>

    <span class="p">;</span> <span class="nv">Special</span> <span class="s s-Atom">case</span><span class="p">,</span> <span class="nv">A</span> <span class="o">is</span> <span class="s s-Atom">a</span> <span class="s s-Atom">root</span><span class="p">.</span> <span class="nv">Set</span> <span class="s s-Atom">the</span> <span class="s s-Atom">output</span> <span class="s s-Atom">to</span> <span class="nv">A</span> <span class="s s-Atom">and</span> <span class="s s-Atom">return</span><span class="p">.</span>
    <span class="nv">IF</span> <span class="p">(</span><span class="nv">ABS</span><span class="p">(</span><span class="nv">A_EVAL</span><span class="p">)</span> <span class="nv">LE</span> <span class="nv">EPSILON</span><span class="p">)</span> <span class="nv">THEN</span> <span class="nv">BEGIN</span>
        <span class="nv">RETURN</span><span class="p">,</span> <span class="nv">A</span>
    <span class="nv">ENDIF</span>

    <span class="p">;</span> <span class="nv">Similarly</span> <span class="s s-Atom">for</span> <span class="nv">B</span><span class="p">,</span> <span class="s s-Atom">if</span> <span class="nv">FUNC</span><span class="p">(</span><span class="nv">B</span><span class="p">)</span> <span class="s s-Atom">~=</span> <span class="mi">0</span><span class="p">,</span> <span class="s s-Atom">return</span> <span class="nv">B</span><span class="p">.</span>
    <span class="nv">IF</span> <span class="p">(</span><span class="nv">ABS</span><span class="p">(</span><span class="nv">B_EVAL</span><span class="p">)</span> <span class="nv">LE</span> <span class="nv">EPSILON</span><span class="p">)</span> <span class="nv">THEN</span> <span class="nv">BEGIN</span>
        <span class="nv">RETURN</span><span class="p">,</span> <span class="nv">B</span>
    <span class="nv">ENDIF</span>

    <span class="p">;</span> <span class="nv">If</span> <span class="nv">FUNC</span><span class="p">(</span><span class="nv">A</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nv">FUNC</span><span class="p">(</span><span class="nv">B</span><span class="p">),</span> <span class="s s-Atom">then</span> <span class="nv">LEFT</span> <span class="o">=</span> <span class="nv">A</span> <span class="s s-Atom">and</span> <span class="nv">RIGHT</span> <span class="o">=</span> <span class="nv">B</span><span class="p">.</span>
    <span class="nv">IF</span> <span class="p">(</span><span class="nv">A_EVAL</span> <span class="nv">LT</span> <span class="nv">B_EVAL</span><span class="p">)</span> <span class="nv">THEN</span> <span class="nv">BEGIN</span>

        <span class="p">;</span> <span class="nv">If</span> <span class="nv">FUNC</span><span class="p">(</span><span class="nv">A</span><span class="p">)</span> <span class="s s-Atom">and</span> <span class="nv">FUNC</span><span class="p">(</span><span class="nv">B</span><span class="p">)</span> <span class="s s-Atom">have</span> <span class="s s-Atom">the</span> <span class="s s-Atom">same</span> <span class="nf">sign</span> <span class="p">(</span><span class="s s-Atom">both</span> <span class="s s-Atom">positive</span> <span class="s s-Atom">or</span>
        <span class="p">;</span> <span class="s s-Atom">both</span> <span class="s s-Atom">negative</span><span class="p">),</span> <span class="s s-Atom">return</span> <span class="nv">NaN</span><span class="p">.</span> <span class="nv">Bisection</span> <span class="o">is</span> <span class="s s-Atom">undefined</span><span class="p">.</span>
        <span class="nv">IF</span> <span class="p">((</span><span class="nv">A_EVAL</span> <span class="nv">GT</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">OR</span> <span class="p">(</span><span class="nv">B_EVAL</span> <span class="nv">LT</span> <span class="mi">0</span><span class="p">))</span> <span class="nv">THEN</span> <span class="nv">BEGIN</span>
            <span class="nv">RETURN</span><span class="p">,</span> <span class="p">(</span><span class="nv">A</span> <span class="o">-</span> <span class="nv">A</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nv">A</span> <span class="o">-</span> <span class="nv">A</span><span class="p">)</span>
        <span class="nv">ENDIF</span>

        <span class="nv">LEFT</span> <span class="o">=</span> <span class="nv">A</span>
        <span class="nv">RIGHT</span> <span class="o">=</span> <span class="nv">B</span>

    <span class="p">;</span> <span class="nv">If</span> <span class="nv">FUNC</span><span class="p">(</span><span class="nv">B</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nv">FUNC</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span> <span class="s s-Atom">then</span> <span class="nv">LEFT</span> <span class="o">=</span> <span class="nv">B</span> <span class="s s-Atom">and</span> <span class="nv">RIGHT</span> <span class="o">=</span> <span class="nv">A</span><span class="p">.</span>
    <span class="nv">ENDIF</span> <span class="nv">ELSE</span> <span class="nv">BEGIN</span>

        <span class="p">;</span> <span class="nv">Same</span> <span class="s s-Atom">sanity</span> <span class="s s-Atom">check</span> <span class="s s-Atom">as</span> <span class="s s-Atom">before</span><span class="p">,</span> <span class="s s-Atom">make</span> <span class="s s-Atom">sure</span> <span class="s s-Atom">the</span> <span class="s s-Atom">signs</span> <span class="s s-Atom">are</span> <span class="s s-Atom">different</span><span class="p">.</span>
        <span class="nv">IF</span> <span class="p">((</span><span class="nv">A_EVAL</span> <span class="nv">LT</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">OR</span> <span class="p">(</span><span class="nv">B_EVAL</span> <span class="nv">GT</span> <span class="mi">0</span><span class="p">))</span> <span class="nv">THEN</span> <span class="nv">BEGIN</span>
            <span class="nv">RETURN</span><span class="p">,</span> <span class="p">(</span><span class="nv">A</span> <span class="o">-</span> <span class="nv">A</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nv">A</span> <span class="o">-</span> <span class="nv">A</span><span class="p">)</span>
        <span class="nv">ENDIF</span>

        <span class="nv">LEFT</span> <span class="o">=</span> <span class="nv">B</span>
        <span class="nv">RIGHT</span> <span class="o">=</span> <span class="nv">A</span>
    <span class="nv">ENDELSE</span>

    <span class="nv">MIDPOINT</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nv">A</span> <span class="o">+</span> <span class="nv">B</span><span class="p">)</span>

    <span class="p">;</span> <span class="nv">Iteratively</span> <span class="s s-Atom">perform</span> <span class="s s-Atom">the</span> <span class="s s-Atom">bisection</span> <span class="s s-Atom">method</span><span class="p">.</span>
    <span class="nv">FOR</span> <span class="nv">ITERS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">MAXIMUM_NUMBER_OF_ITERATIONS</span> <span class="nv">DO</span> <span class="nv">BEGIN</span>

        <span class="p">;</span> <span class="nv">The</span> <span class="s s-Atom">interval</span> <span class="o">is</span> <span class="s s-Atom">cut</span> <span class="s s-Atom">in</span> <span class="s s-Atom">half</span> <span class="s s-Atom">based</span> <span class="s s-Atom">on</span> <span class="s s-Atom">the</span> <span class="s s-Atom">sign</span> <span class="s s-Atom">of</span> <span class="nv">FUNC</span><span class="p">(</span><span class="nv">MIDPOINT</span><span class="p">).</span>
        <span class="p">;</span> <span class="nv">Compute</span> <span class="s s-Atom">this</span> <span class="s s-Atom">and</span> <span class="s s-Atom">compare</span><span class="p">.</span>
        <span class="nv">EVAL</span> <span class="o">=</span> <span class="nv">CALL_FUNCTION</span><span class="p">(</span><span class="nv">FUNC</span><span class="p">,</span> <span class="nv">MIDPOINT</span><span class="p">)</span>

        <span class="p">;</span> <span class="nv">If</span> <span class="nv">MIDPOINT</span> <span class="o">is</span> <span class="s s-Atom">close</span> <span class="s s-Atom">to</span> <span class="s s-Atom">a</span> <span class="s s-Atom">root</span> <span class="s s-Atom">we</span> <span class="s s-Atom">can</span> <span class="s s-Atom">exit</span> <span class="s s-Atom">the</span> <span class="s s-Atom">function</span><span class="p">.</span>
        <span class="nv">IF</span> <span class="p">(</span><span class="nv">ABS</span><span class="p">(</span><span class="nv">EVAL</span><span class="p">)</span> <span class="nv">LE</span> <span class="nv">EPSILON</span><span class="p">)</span> <span class="nv">THEN</span> <span class="nv">BEGIN</span>
            <span class="nv">BREAK</span>
        <span class="nv">ENDIF</span>

        <span class="p">;</span> <span class="nv">Otherwise</span><span class="p">,</span> <span class="s s-Atom">divide</span> <span class="s s-Atom">the</span> <span class="s s-Atom">range</span> <span class="s s-Atom">in</span> <span class="s s-Atom">half</span><span class="p">.</span> <span class="nv">If</span> <span class="nv">EVAL</span> <span class="o">is</span> <span class="s s-Atom">negative</span> <span class="s s-Atom">we</span>
        <span class="p">;</span> <span class="s s-Atom">replace</span> <span class="nv">LEFT</span> <span class="s s-Atom">with</span> <span class="nv">MIDPOINT</span> <span class="s s-Atom">and</span> <span class="s s-Atom">move</span> <span class="nv">MIDPOINT</span> <span class="s s-Atom">closer</span> <span class="s s-Atom">to</span> <span class="nv">RIGHT</span><span class="p">.</span>
        <span class="nv">IF</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">LT</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">THEN</span> <span class="nv">BEGIN</span>
            <span class="nv">LEFT</span> <span class="o">=</span> <span class="nv">MIDPOINT</span>
            <span class="nv">MIDPOINT</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nv">MIDPOINT</span> <span class="o">+</span> <span class="nv">RIGHT</span><span class="p">)</span>

        <span class="p">;</span> <span class="nv">Likewise</span><span class="p">,</span> <span class="s s-Atom">if</span> <span class="nv">EVAL</span> <span class="o">is</span> <span class="s s-Atom">positive</span><span class="p">,</span> <span class="s s-Atom">replace</span> <span class="nv">RIGHT</span> <span class="s s-Atom">with</span> <span class="nv">MIDPOINT</span> <span class="s s-Atom">and</span>
        <span class="p">;</span> <span class="s s-Atom">move</span> <span class="nv">MIDPOINT</span> <span class="s s-Atom">closer</span> <span class="s s-Atom">to</span> <span class="nv">LEFT</span><span class="p">.</span>
        <span class="nv">ENDIF</span> <span class="nv">ELSE</span> <span class="nv">BEGIN</span>
            <span class="nv">RIGHT</span> <span class="o">=</span> <span class="nv">MIDPOINT</span>
            <span class="nv">MIDPOINT</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nv">LEFT</span> <span class="o">+</span> <span class="nv">MIDPOINT</span><span class="p">)</span>
        <span class="nv">ENDELSE</span>
    <span class="nv">END</span>

    <span class="p">;</span> <span class="nv">Provided</span> <span class="p">|</span><span class="nv">B</span> <span class="o">-</span> <span class="nv">A</span><span class="p">|</span> <span class="o">is</span> <span class="o">not</span> <span class="s s-Atom">too</span> <span class="s s-Atom">big</span><span class="p">,</span> <span class="s s-Atom">we</span> <span class="s s-Atom">should</span> <span class="s s-Atom">now</span> <span class="s s-Atom">have</span> <span class="s s-Atom">a</span> <span class="s s-Atom">very</span> <span class="s s-Atom">good</span>
    <span class="p">;</span> <span class="s s-Atom">approximation</span> <span class="s s-Atom">to</span> <span class="s s-Atom">the</span> <span class="s s-Atom">root</span><span class="p">.</span>
    <span class="nv">RETURN</span><span class="p">,</span> <span class="nv">MIDPOINT</span>
<span class="nv">END</span>

<span class="p">;</span> <span class="nv">Program</span> <span class="s s-Atom">for</span> <span class="s s-Atom">testing</span> <span class="s s-Atom">our</span> <span class="s s-Atom">implementation</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span> <span class="s s-Atom">bisection</span> <span class="s s-Atom">method</span><span class="p">.</span>
<span class="nv">PRO</span> <span class="nv">MAIN</span>

    <span class="p">;</span> <span class="nv">Tells</span> <span class="s s-Atom">the</span> <span class="s s-Atom">compiler</span> <span class="s s-Atom">that</span> <span class="s s-Atom">integers</span> <span class="s s-Atom">should</span> <span class="s s-Atom">be</span> <span class="mi">32</span> <span class="s s-Atom">bits</span><span class="p">,</span> <span class="o">not</span> <span class="mf">16.</span>
    <span class="nv">COMPILE_OPT</span> <span class="nv">IDL2</span>

    <span class="p">;</span> <span class="nv">Pi</span> <span class="o">is</span> <span class="s s-Atom">somewhere</span> <span class="s s-Atom">between</span> <span class="mi">3</span> <span class="s s-Atom">and</span> <span class="mi">4</span><span class="p">,</span> <span class="s s-Atom">use</span> <span class="s s-Atom">this</span> <span class="s s-Atom">interval</span><span class="p">.</span>
    <span class="nv">A</span> <span class="o">=</span> <span class="nv">DOUBLE</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="nv">B</span> <span class="o">=</span> <span class="nv">DOUBLE</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>

    <span class="p">;</span> <span class="nv">Run</span> <span class="s s-Atom">the</span> <span class="s s-Atom">routine</span><span class="p">,</span> <span class="s s-Atom">compute</span> <span class="s s-Atom">pi</span><span class="p">,</span> <span class="s s-Atom">and</span> <span class="s s-Atom">print</span> <span class="s s-Atom">the</span> <span class="s s-Atom">result</span><span class="p">.</span>
    <span class="nv">PI_BY_BISECTION</span> <span class="o">=</span> <span class="nv">BISECTION_METHOD</span><span class="p">(</span><span class="s2">&quot;SIN&quot;</span><span class="p">,</span> <span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">)</span>
    <span class="nv">PRINT</span><span class="p">,</span> <span class="nv">PI_BY_BISECTION</span><span class="p">,</span> <span class="nv">FORMAT</span> <span class="o">=</span> <span class="s s-Atom">&#39;PI = %18.16f&#39;</span>

<span class="nv">END</span>
</pre></div>

<h2 id="m">M<br /></h2>
<div class="highlight"><pre><span></span><span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%                                   LICENSE                                    %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   This file is part of mitx_mathematics_programming_examples.                %</span>
<span class="c">%                                                                              %</span>
<span class="c">%   mitx_mathematics_programming_examples is free software: you can            %</span>
<span class="c">%   redistribute it and/or modify it under the terms of the GNU General Public %</span>
<span class="c">%   License as published by the Free Software Foundation, either version 3 of  %</span>
<span class="c">%   the License, or (at your option) any later version.                        %</span>
<span class="c">%                                                                              %</span>
<span class="c">%   mitx_mathematics_programming_examples is distributed in the hope that it   %</span>
<span class="c">%   will be useful, but WITHOUT ANY WARRANTY; without even the implied         %</span>
<span class="c">%   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  %</span>
<span class="c">%   GNU General Public License for more details.                               %</span>
<span class="c">%                                                                              %</span>
<span class="c">%   You should have received a copy of the GNU General Public License          %</span>
<span class="c">%   along with mitx_mathematics_programming_examples.  If not, see             %</span>
<span class="c">%   &lt;https://www.gnu.org/licenses/&gt;.                                           %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   Purpose:                                                                   %</span>
<span class="c">%       Calculates roots of a function using bisection.                        %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   Author:     Ryan Maguire                                                   %</span>
<span class="c">%   Date:       March 29, 2025.                                                %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   Function:                                                                  %</span>
<span class="c">%       bisection                                                              %</span>
<span class="c">%   Purpose:                                                                   %</span>
<span class="c">%       Computes the root of a function f between a and b.                     %</span>
<span class="c">%   Arguments:                                                                 %</span>
<span class="c">%       f (function):                                                          %</span>
<span class="c">%           A function f: R -&gt; R. The root of f is computed.                   %</span>
<span class="c">%       a (real):                                                              %</span>
<span class="c">%           One of the endpoints of the interval for f.                        %</span>
<span class="c">%       b (real):                                                              %</span>
<span class="c">%           The other endpoint for f.                                          %</span>
<span class="c">%   Output:                                                                    %</span>
<span class="c">%       root (real):                                                           %</span>
<span class="c">%           A root of the function f between a and b.                          %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="k">function</span><span class="w"> </span>root<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">bisection</span><span class="p">(</span>f, a, b<span class="p">)</span>

<span class="w">    </span><span class="c">% Tell the algorithm to stop after several iterations to avoid an</span>
<span class="w">    </span><span class="c">% infinite loop. Double precision numbers have 52 bits in the mantissa,</span>
<span class="w">    </span><span class="c">% so if |b - a| ~= 1, after 52 iterations of bisection we will get as</span>
<span class="w">    </span><span class="c">% close as we can to the root. To allow for |b - a| to be larger, halt</span>
<span class="w">    </span><span class="c">% the algorithm after at most 64 steps.</span>
<span class="w">    </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>

<span class="w">    </span><span class="c">% The maximum allowed error. This is double precision epsilon.</span>
<span class="w">    </span><span class="n">epsilon</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="c">% Evaluate f at the two endpoints to determine which is positive and</span>
<span class="w">    </span><span class="c">% which is negative. We transform [a, b] to [left, right] by doing this.</span>
<span class="w">    </span><span class="n">a_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="n">b_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="c">% Rare case, f(a) = 0. Return a, no bisection needed.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">        </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c">% Similarly, if f(b) = 0, then we have already found the root. Return b.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">        </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c">% Compare the two evaluations and set left and right accordingly.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b_eval</span>

<span class="w">        </span><span class="c">% If both evaluations are negative, or if both are positive, then</span>
<span class="w">        </span><span class="c">% the bisection method will not work. Return NaN.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c">% Otherwise, since f(a) &lt; f(b), set left = a and right = b.</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">    </span><span class="c">% In this case the function starts positive and tends to a negative.</span>
<span class="w">    </span><span class="k">else</span>

<span class="w">        </span><span class="c">% Same sanity check as before. We need one evaluation to be</span>
<span class="w">        </span><span class="c">% negative and one to be positive. Abort if both have the same sign.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c">% Since f(a) &gt; f(b), set left = b and right = a.</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c">% Start the bisection method. Compute the midpoint of a and b.</span>
<span class="w">    </span><span class="n">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="c">% Iteratively apply the bisection method.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">maximum_number_of_iterations</span>

<span class="w">        </span><span class="c">% If f(x) is very small, we are close to a root and can break out</span>
<span class="w">        </span><span class="c">% of this for loop. Check for this.</span>
<span class="w">        </span><span class="n">f_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">abs</span><span class="p">(</span><span class="n">f_eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c">% Apply bisection to get a better approximation for the root. We</span>
<span class="w">        </span><span class="c">% have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the</span>
<span class="w">        </span><span class="c">% interval [left, right] with [midpoint, right]. Set left to the</span>
<span class="w">        </span><span class="c">% midpoint and reset the midpoint to be closer to right.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">f_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>

<span class="w">        </span><span class="c">% In the other case, f(midpoint) &gt; 0, we replace right with the</span>
<span class="w">        </span><span class="c">% midpoint, changing [left, right] into [left, midpoint]. We then</span>
<span class="w">        </span><span class="c">% set the midpoint to be closer to left.</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">);</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c">% After n iterations, we are no more than |b - a| / 2^n away from the</span>
<span class="w">    </span><span class="c">% root of the function. 1 / 2^n goes to zero very quickly, meaning the</span>
<span class="w">    </span><span class="c">% convergence is very quick.</span>
<span class="w">    </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>

<span class="k">end</span>

<span class="c">% pi is somewhere between 3 and 4, and it is a root to sine.</span>
<span class="n">a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="c">% Compute pi using bisection. We should get pi = 3.14159..., accurate</span>
<span class="c">% to about 16 decimals.</span>
<span class="n">pi_by_bisection</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bisection</span><span class="p">(@</span><span class="nb">sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;pi = %.16f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi_by_bisection</span><span class="p">);</span>
</pre></div>

<h2 id="py">Py<br /></h2>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">################################################################################</span>
<span class="sd">#                                   LICENSE                                    #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   This file is part of mitx_mathematics_programming_examples.                #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is free software: you can            #</span>
<span class="sd">#   redistribute it and/or modify it under the terms of the GNU General Public #</span>
<span class="sd">#   License as published by the Free Software Foundation, either version 3 of  #</span>
<span class="sd">#   the License, or (at your option) any later version.                        #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   mitx_mathematics_programming_examples is distributed in the hope that it   #</span>
<span class="sd">#   will be useful, but WITHOUT ANY WARRANTY; without even the implied         #</span>
<span class="sd">#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  #</span>
<span class="sd">#   GNU General Public License for more details.                               #</span>
<span class="sd">#                                                                              #</span>
<span class="sd">#   You should have received a copy of the GNU General Public License          #</span>
<span class="sd">#   along with mitx_mathematics_programming_examples.  If not, see             #</span>
<span class="sd">#   &lt;https://www.gnu.org/licenses/&gt;.                                           #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Purpose:                                                                   #</span>
<span class="sd">#       Calculates roots of a function using bisection.                        #</span>
<span class="sd">################################################################################</span>
<span class="sd">#   Author:     Ryan Maguire                                                   #</span>
<span class="sd">#   Date:       April 17, 2025.                                                #</span>
<span class="sd">################################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Pylint doesn&#39;t like &quot;x&quot; as a variable name. Disable this warning.</span>
<span class="c1"># pylint: disable = invalid-name</span>

<span class="c1"># sin provided here.</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># Computes the root of a function via bisection.</span>
<span class="k">def</span> <span class="nf">bisection</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function:</span>
<span class="sd">            bisection</span>
<span class="sd">        Purpose:</span>
<span class="sd">            Computes the root of a function f between a and b.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            f (function):</span>
<span class="sd">                A function f: R -&gt; R. The root of f is computed.</span>
<span class="sd">            a (float):</span>
<span class="sd">                One of the endpoints of the interval for f.</span>
<span class="sd">            b (float):</span>
<span class="sd">                The other endpoint for f.</span>
<span class="sd">        Output:</span>
<span class="sd">            root (float):</span>
<span class="sd">                A root of the function f between a and b.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Tell the algorithm to stop after several iterations to avoid an</span>
    <span class="c1"># infinite loop. Double precision numbers have 52 bits in the mantissa,</span>
    <span class="c1"># so if |b - a| ~= 1, after 52 iterations of bisection we will get as</span>
    <span class="c1"># close as we can to the root. To allow for |b - a| to be larger, halt</span>
    <span class="c1"># the algorithm after at most 64 steps.</span>
    <span class="n">maximum_number_of_iterations</span> <span class="o">=</span> <span class="mi">64</span>

    <span class="c1"># The maximum allowed error. This is double precision epsilon.</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">2.220446049250313E-16</span>

    <span class="c1"># Evaluate f at the two endpoints to determine which is positive and</span>
    <span class="c1"># which is negative. We transform [a, b] to [left, right] by doing this.</span>
    <span class="n">a_eval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b_eval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="c1"># Rare case, f(a) = 0. Return a, no bisection needed.</span>
    <span class="k">if</span> <span class="n">a_eval</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="c1"># Similarly, if f(b) = 0, then we have already found the root. Return b.</span>
    <span class="k">if</span> <span class="n">b_eval</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span>

    <span class="c1"># Compare the two evaluations and set left and right accordingly.</span>
    <span class="k">if</span> <span class="n">a_eval</span> <span class="o">&lt;</span> <span class="n">b_eval</span><span class="p">:</span>

        <span class="c1"># If both evaluations are negative, or if both are positive, then</span>
        <span class="c1"># the bisection method will not work. Return NaN.</span>
        <span class="k">if</span> <span class="n">b_eval</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">a_eval</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>

        <span class="c1"># Otherwise, since f(a) &lt; f(b), set left = a and right = b.</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">b</span>

    <span class="c1"># In this case the function starts positive and tends to a negative.</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Same sanity check as before. We need one evaluation to be</span>
        <span class="c1"># negative and one to be positive. Abort if both have the same sign.</span>
        <span class="k">if</span> <span class="n">a_eval</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">b_eval</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>

        <span class="c1"># Since f(a) &gt; f(b), set left = b and right = a.</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">a</span>

    <span class="c1"># Start the bisection method. Compute the midpoint of a and b.</span>
    <span class="n">midpoint</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

    <span class="c1"># Iteratively apply the bisection method.</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maximum_number_of_iterations</span><span class="p">):</span>

        <span class="c1"># If f(x) is very small, we are close to a root and can break out</span>
        <span class="c1"># of this for loop. Check for this.</span>
        <span class="n">f_eval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f_eval</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">epsilon</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Apply bisection to get a better approximation for the root. We</span>
        <span class="c1"># have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the</span>
        <span class="c1"># interval [left, right] with [midpoint, right]. Set left to the</span>
        <span class="c1"># midpoint and reset the midpoint to be closer to right.</span>
        <span class="k">if</span> <span class="n">f_eval</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">midpoint</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">midpoint</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>

        <span class="c1"># In the other case, f(midpoint) &gt; 0, we replace right with the</span>
        <span class="c1"># midpoint, changing [left, right] into [left, midpoint]. We then</span>
        <span class="c1"># set the midpoint to be closer to left.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">midpoint</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">midpoint</span><span class="p">)</span>

    <span class="c1"># After n iterations, we are no more than |b - a| / 2^n away from the</span>
    <span class="c1"># root of the function. 1 / 2^n goes to zero very quickly, meaning the</span>
    <span class="c1"># convergence is very quick.</span>
    <span class="k">return</span> <span class="n">midpoint</span>

<span class="c1"># pi is somewhere between 3 and 4, and it is a root to sine.</span>
<span class="n">A</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="n">B</span> <span class="o">=</span> <span class="mf">4.0</span>

<span class="c1"># Compute pi using bisection. We should get pi = 3.14159..., accurate</span>
<span class="c1"># to about 16 decimals.</span>
<span class="n">pi_by_bisection</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;pi = </span><span class="si">{</span><span class="n">pi_by_bisection</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

<h2 id="js">Js<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using bisection.                    *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/05/18                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Computes the root of a function using the bisection method.               */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">bisectionMethod</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">64</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Getting exact roots is hard using floating-point numbers. Allow a     *</span>
<span class="cm">     *  tolerance in our computation. This value is double precision epsilon. */</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">EPSILON</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The midpoint for the bisection method. This will update as we iterate.*/</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of the number of iterations performed.     */</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">iters</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  We do not require a &lt; b, nor do we require f(a) &lt; f(b). We only need  *</span>
<span class="cm">     *  one of these to evaluate to a negative under f and one to evaluate to *</span>
<span class="cm">     *  positive. We will call the negative entry left and positive one right.*/</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">left</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">right</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Evaluate f at the two endpoints to determine which is positive and    *</span>
<span class="cm">     *  which is negative. We transform [a, b] to [left, right] by doing this.*/</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">A_EVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">B_EVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.                   */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">A_EVAL</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Similarly, if f(b) = 0, then we have already found the root. Return b.*/</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">B_EVAL</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Compare the two evaluations and set left and right accordingly.       */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">A_EVAL</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">B_EVAL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If both evaluations are negative, or if both are positive, then   *</span>
<span class="cm">         *  the bisection method will not work. Return NaN.                   */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">B_EVAL</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="nx">A_EVAL</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.         */</span>
<span class="w">        </span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">a</span><span class="p">;</span>
<span class="w">        </span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  In this case the function starts positive and tends to a negative.    */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be         *</span>
<span class="cm">         *  negative and one to be positive. Abort if both have the same sign.*/</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">A_EVAL</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="nx">B_EVAL</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">a</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                    */</span>
<span class="w">        </span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
<span class="w">        </span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.          */</span>
<span class="w">    </span><span class="nx">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Iteratively divide the range in half to find the root.                */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nx">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="nx">iters</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If f(x) is very small, we are close to a root and can break out   *</span>
<span class="cm">         *  of this for loop. Check for this.                                 */</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">EVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">midpoint</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">EVAL</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Apply bisection to get a better approximation for the root. We    *</span>
<span class="cm">         *  have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the      *</span>
<span class="cm">         *  interval [left, right] with [midpoint, right]. Set left to the    *</span>
<span class="cm">         *  midpoint and reset the midpoint to be closer to right.            */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">EVAL</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="nx">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">right</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  In the other case, f(midpoint) &gt; 0, we replace right with the     *</span>
<span class="cm">         *  midpoint, changing [left, right] into [left, midpoint]. We then   *</span>
<span class="cm">         *  set the midpoint to be closer to left.                            */</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="nx">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  After n iterations, we are no more than |b - a| / 2^n away from the   *</span>
<span class="cm">     *  root of the function. 1 / 2^n goes to zero very quickly, meaning the  *</span>
<span class="cm">     *  convergence is very quick.                                            */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">midpoint</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of bisectionMethod.                                                   */</span>

<span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.                */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate       *</span>
<span class="cm"> *  to about 16 decimals.                                                     */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">PI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">bisectionMethod</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">,</span><span class="w"> </span><span class="nx">A</span><span class="p">,</span><span class="w"> </span><span class="nx">B</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;pi = &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">PI</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mf">16</span><span class="p">));</span>
</pre></div>

<h2 id="c">C<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using bisection.                    *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/09                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  stdio.h provides the &quot;printf&quot; function, used for printing text.           */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cm">/*  Floating-point absolute value function, fabs, provided here.              */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>

<span class="cm">/*  Function pointer notation is a little confusing. Create a typedef for it  *</span>
<span class="cm"> *  so we do not need to explicitly use it later.                             */</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>

<span class="cm">/*  Computes the root of a function using the bisection method.               */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">bisection_method</span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Getting exact roots is hard using floating-point numbers. Allow a     *</span>
<span class="cm">     *  tolerance in our computation. This value is double precision epsilon. */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of how many iterations we have performed.  */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The midpoint for the bisection method. This will update as we iterate.*/</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  We do not require a &lt; b, nor do we require f(a) &lt; f(b). We only need  *</span>
<span class="cm">     *  one of these to evaluate to a negative under f and one to evaluate to *</span>
<span class="cm">     *  positive. We will call the negative entry left and positive one right.*/</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Evaluate f at the two endpoints to determine which is positive and    *</span>
<span class="cm">     *  which is negative. We transform [a, b] to [left, right] by doing this.*/</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.                   */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Similarly, if f(b) = 0, then we have already found the root. Return b.*/</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Compare the two evaluations and set left and right accordingly.       */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b_eval</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  If both evaluations are negative, or if both are positive, then   *</span>
<span class="cm">         *  the bisection method will not work. Return NaN.                   */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.         */</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  In this case the function starts positive and tends to a negative.    */</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be         *</span>
<span class="cm">         *  negative and one to be positive. Abort if both have the same sign.*/</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                    */</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.          */</span>
<span class="w">    </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Iteratively divide the range in half to find the root.                */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  If f(x) is very small, we are close to a root and can break out   *</span>
<span class="cm">         *  of this for loop. Check for this.                                 */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Apply bisection to get a better approximation for the root. We    *</span>
<span class="cm">         *  have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the      *</span>
<span class="cm">         *  interval [left, right] with [midpoint, right]. Set left to the    *</span>
<span class="cm">         *  midpoint and reset the midpoint to be closer to right.            */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  In the other case, f(midpoint) &gt; 0, we replace right with the     *</span>
<span class="cm">         *  midpoint, changing [left, right] into [left, midpoint]. We then   *</span>
<span class="cm">         *  set the midpoint to be closer to left.                            */</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  After n iterations, we are no more than |b - a| / 2^n away from the   *</span>
<span class="cm">     *  root of the function. 1 / 2^n goes to zero very quickly, meaning the  *</span>
<span class="cm">     *  convergence is very quick.                                            */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of bisection_method.                                                  */</span>

<span class="cm">/*  Main routine used for testing our implementation of the bisection method. */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.            */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate   *</span>
<span class="cm">     *  to about 16 decimals.                                                 */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bisection_method</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;pi = %.16f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h2 id="java">Java<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using the bisection method.         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/28                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Class providing an implementation of the bisection method.                */</span>
<span class="kd">final</span><span class="w"> </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Bisection</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Interface used for defining functions of the type f: R -&gt; R.          */</span>
<span class="w">    </span><span class="kd">interface</span> <span class="nc">Function</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  The error after n iterations is |b - a| / 2^n. Since double has a     *</span>
<span class="cm">     *  52-bit mantissa, if |b - a| ~= 1, then after 52 steps we can halt the *</span>
<span class="cm">     *  program. To allow for |b - a| to be larger, we stop the process after *</span>
<span class="cm">     *  at most 64 iterations.                                                */</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The maximum allowed error. This is double precision epsilon.          */</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Computes the root of a function using the bisection method.           */</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">root</span><span class="p">(</span><span class="n">Function</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Variable for keeping track of the number of iterations.           */</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  The midpoint for the bisection. This updates as we iterate.       */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  We do not require a &lt; b, nor f(a) &lt; f(b). We need one of          *</span>
<span class="cm">         *  these to evaluate negative under f and one to evaluate to         *</span>
<span class="cm">         *  positive. Call the negative entry left and positive one right.    */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Evaluate f at the endpoints to determine which is positive        *</span>
<span class="cm">         *  and which is negative, transforming [a, b] to [left, right].      */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">aEval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="na">evaluate</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">bEval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="na">evaluate</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.               */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Similarly, if f(b) = 0, then we found the root. Return b.         */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bEval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Compare the two evaluations and set the left and right values.    */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bEval</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  If both evaluations are negative, or if both are positive,    *</span>
<span class="cm">             *  then the bisection method will not work. Return NaN.          */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">aEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.     */</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  In this case the function starts positive and goes negative.      */</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be     *</span>
<span class="cm">             *  negative and one to be positive. Abort if the signs agree.    */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">bEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                */</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.      */</span>
<span class="w">        </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Iteratively divide the range in half to find the root.            */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximumNumberOfIterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  If f(x) is very small, we are close to a root and can         *</span>
<span class="cm">             *  break out of this for loop. Check for this.                   */</span>
<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="na">evaluate</span><span class="p">(</span><span class="n">midpoint</span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">abs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Apply bisection to get a better approximation. We have        *</span>
<span class="cm">             *  f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the       *</span>
<span class="cm">             *  interval [left, right] with [midpoint, right]. Set left       *</span>
<span class="cm">             *  to the midpoint and set midpoint to be closer to right.       */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">                </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/*  If f(midpoint) &gt; 0, then replace right with the midpoint,     *</span>
<span class="cm">             *  changing [left, right] into [left, midpoint]. We then set     *</span>
<span class="cm">             *  the midpoint to be closer to left.                            */</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">                </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  After n iterations, we are at most |b - a| / 2^n from the         *</span>
<span class="cm">         *  root of the function. 1 / 2^n goes to zero very quickly,          *</span>
<span class="cm">         *  meaning the convergence is very quick.                            */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/*  End of root.                                                          */</span>

<span class="w">    </span><span class="cm">/*  Main routine used for testing our Bisection implementation.           */</span>
<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.        */</span>
<span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Create a function that evaluates sine using Math.sin.             */</span>
<span class="w">        </span><span class="n">Function</span><span class="w"> </span><span class="n">sin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Function</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  The evaluator simply calls the standard library function.     */</span>
<span class="w">            </span><span class="kd">public</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159...,        *</span>
<span class="cm">         *  accurate to about 16 decimals.                                    */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bisection</span><span class="p">.</span><span class="na">root</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">printf</span><span class="p">(</span><span class="s">&quot;pi = %.16f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="m-1">M<br /></h2>
<div class="highlight"><pre><span></span><span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%                                   LICENSE                                    %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   This file is part of mitx_mathematics_programming_examples.                %</span>
<span class="c">%                                                                              %</span>
<span class="c">%   mitx_mathematics_programming_examples is free software: you can            %</span>
<span class="c">%   redistribute it and/or modify it under the terms of the GNU General Public %</span>
<span class="c">%   License as published by the Free Software Foundation, either version 3 of  %</span>
<span class="c">%   the License, or (at your option) any later version.                        %</span>
<span class="c">%                                                                              %</span>
<span class="c">%   mitx_mathematics_programming_examples is distributed in the hope that it   %</span>
<span class="c">%   will be useful, but WITHOUT ANY WARRANTY; without even the implied         %</span>
<span class="c">%   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  %</span>
<span class="c">%   GNU General Public License for more details.                               %</span>
<span class="c">%                                                                              %</span>
<span class="c">%   You should have received a copy of the GNU General Public License          %</span>
<span class="c">%   along with mitx_mathematics_programming_examples.  If not, see             %</span>
<span class="c">%   &lt;https://www.gnu.org/licenses/&gt;.                                           %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   Purpose:                                                                   %</span>
<span class="c">%       Calculates roots of a function using bisection.                        %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   Author:     Ryan Maguire                                                   %</span>
<span class="c">%   Date:       March 29, 2025.                                                %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%   Function:                                                                  %</span>
<span class="c">%       bisection                                                              %</span>
<span class="c">%   Purpose:                                                                   %</span>
<span class="c">%       Computes the root of a function f between a and b.                     %</span>
<span class="c">%   Arguments:                                                                 %</span>
<span class="c">%       f (function):                                                          %</span>
<span class="c">%           A function f: R -&gt; R. The root of f is computed.                   %</span>
<span class="c">%       a (real):                                                              %</span>
<span class="c">%           One of the endpoints of the interval for f.                        %</span>
<span class="c">%       b (real):                                                              %</span>
<span class="c">%           The other endpoint for f.                                          %</span>
<span class="c">%   Output:                                                                    %</span>
<span class="c">%       root (real):                                                           %</span>
<span class="c">%           A root of the function f between a and b.                          %</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="k">function</span><span class="w"> </span>root<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">bisection</span><span class="p">(</span>f, a, b<span class="p">)</span>

<span class="w">    </span><span class="c">% Tell the algorithm to stop after several iterations to avoid an</span>
<span class="w">    </span><span class="c">% infinite loop. Double precision numbers have 52 bits in the mantissa,</span>
<span class="w">    </span><span class="c">% so if |b - a| ~= 1, after 52 iterations of bisection we will get as</span>
<span class="w">    </span><span class="c">% close as we can to the root. To allow for |b - a| to be larger, halt</span>
<span class="w">    </span><span class="c">% the algorithm after at most 64 steps.</span>
<span class="w">    </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>

<span class="w">    </span><span class="c">% The maximum allowed error. This is double precision epsilon.</span>
<span class="w">    </span><span class="n">epsilon</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="c">% Evaluate f at the two endpoints to determine which is positive and</span>
<span class="w">    </span><span class="c">% which is negative. We transform [a, b] to [left, right] by doing this.</span>
<span class="w">    </span><span class="n">a_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="n">b_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="c">% Rare case, f(a) = 0. Return a, no bisection needed.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">        </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c">% Similarly, if f(b) = 0, then we have already found the root. Return b.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">        </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c">% Compare the two evaluations and set left and right accordingly.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b_eval</span>

<span class="w">        </span><span class="c">% If both evaluations are negative, or if both are positive, then</span>
<span class="w">        </span><span class="c">% the bisection method will not work. Return NaN.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c">% Otherwise, since f(a) &lt; f(b), set left = a and right = b.</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">    </span><span class="c">% In this case the function starts positive and tends to a negative.</span>
<span class="w">    </span><span class="k">else</span>

<span class="w">        </span><span class="c">% Same sanity check as before. We need one evaluation to be</span>
<span class="w">        </span><span class="c">% negative and one to be positive. Abort if both have the same sign.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c">% Since f(a) &gt; f(b), set left = b and right = a.</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c">% Start the bisection method. Compute the midpoint of a and b.</span>
<span class="w">    </span><span class="n">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="c">% Iteratively apply the bisection method.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">maximum_number_of_iterations</span>

<span class="w">        </span><span class="c">% If f(x) is very small, we are close to a root and can break out</span>
<span class="w">        </span><span class="c">% of this for loop. Check for this.</span>
<span class="w">        </span><span class="n">f_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">abs</span><span class="p">(</span><span class="n">f_eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">        </span><span class="c">% Apply bisection to get a better approximation for the root. We</span>
<span class="w">        </span><span class="c">% have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the</span>
<span class="w">        </span><span class="c">% interval [left, right] with [midpoint, right]. Set left to the</span>
<span class="w">        </span><span class="c">% midpoint and reset the midpoint to be closer to right.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">f_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>

<span class="w">        </span><span class="c">% In the other case, f(midpoint) &gt; 0, we replace right with the</span>
<span class="w">        </span><span class="c">% midpoint, changing [left, right] into [left, midpoint]. We then</span>
<span class="w">        </span><span class="c">% set the midpoint to be closer to left.</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">);</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c">% After n iterations, we are no more than |b - a| / 2^n away from the</span>
<span class="w">    </span><span class="c">% root of the function. 1 / 2^n goes to zero very quickly, meaning the</span>
<span class="w">    </span><span class="c">% convergence is very quick.</span>
<span class="w">    </span><span class="n">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>

<span class="k">end</span>

<span class="c">% pi is somewhere between 3 and 4, and it is a root to sine.</span>
<span class="n">a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="c">% Compute pi using bisection. We should get pi = 3.14159..., accurate</span>
<span class="c">% to about 16 decimals.</span>
<span class="n">pi_by_bisection</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bisection</span><span class="p">(@</span><span class="nb">sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;pi = %.16f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi_by_bisection</span><span class="p">);</span>
</pre></div>

<h2 id="f90">F90<br /></h2>
<div class="highlight"><pre><span></span><span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!                                   LICENSE                                    !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!   This file is part of mitx_mathematics_programming_examples.                !</span>
<span class="c">!                                                                              !</span>
<span class="c">!   mitx_mathematics_programming_examples is free software: you can            !</span>
<span class="c">!   redistribute it and/or modify it under the terms of the GNU General Public !</span>
<span class="c">!   License as published by the Free Software Foundation, either version 3 of  !</span>
<span class="c">!   the License, or (at your option) any later version.                        !</span>
<span class="c">!                                                                              !</span>
<span class="c">!   mitx_mathematics_programming_examples is distributed in the hope that it   !</span>
<span class="c">!   will be useful but WITHOUT ANY WARRANTY; without even the implied warranty !</span>
<span class="c">!   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           !</span>
<span class="c">!   GNU General Public License for more details.                               !</span>
<span class="c">!                                                                              !</span>
<span class="c">!   You should have received a copy of the GNU General Public License          !</span>
<span class="c">!   along with mitx_mathematics_programming_examples.  If not, see             !</span>
<span class="c">!   &lt;https://www.gnu.org/licenses/&gt;.                                           !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!   Purpose:                                                                   !</span>
<span class="c">!       Calculates roots using the bisection method.                           !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="c">!   Author: Ryan Maguire                                                       !</span>
<span class="c">!   Date:   2025/03/09                                                         !</span>
<span class="c">!------------------------------------------------------------------------------!</span>
<span class="k">MODULE </span><span class="n">BISECTION</span>

<span class="w">    </span><span class="k">IMPLICIT NONE</span>

<span class="w">    </span><span class="c">! Given a continuous function defined on [a, b], the nth iteration of the</span>
<span class="w">    </span><span class="c">! bisection method is at most |b - a| / 2^n away from the root. A double</span>
<span class="w">    </span><span class="c">! precision number has 52 bits in the mantissa, meaning if |b - a| ~= 1,</span>
<span class="w">    </span><span class="c">! then after 52 iterations we are as close to the root as we can get.</span>
<span class="w">    </span><span class="c">! To allow for a larger range, halt the algorithm after 64 iterations.</span>
<span class="w">    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span>

<span class="w">    </span><span class="c">! Maximum allowed error. This is double precision epsilon.</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">EPSILON</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span>

<span class="w">    </span><span class="k">CONTAINS</span>

<span class="w">    </span><span class="c">!--------------------------------------------------------------------------!</span>
<span class="w">    </span><span class="c">!   Function:                                                              !</span>
<span class="w">    </span><span class="c">!       BISECTION_METHOD                                                   !</span>
<span class="w">    </span><span class="c">!   Purpose:                                                               !</span>
<span class="w">    </span><span class="c">!       Computes roots using the bisection method.                         !</span>
<span class="w">    </span><span class="c">!   Arguments:                                                             !</span>
<span class="w">    </span><span class="c">!       FUNC (FUNCTION):                                                   !</span>
<span class="w">    </span><span class="c">!           A function from [A, B] to the real numbers.                    !</span>
<span class="w">    </span><span class="c">!       A (REAL):                                                          !</span>
<span class="w">    </span><span class="c">!           One of the endpoints for the interval.                         !</span>
<span class="w">    </span><span class="c">!       B (REAL):                                                          !</span>
<span class="w">    </span><span class="c">!           The other the endpoint for the interval.                       !</span>
<span class="w">    </span><span class="c">!   OUTPUT:                                                                !</span>
<span class="w">    </span><span class="c">!       ROOT (REAL):                                                       !</span>
<span class="w">    </span><span class="c">!           A root for FUNC.                                               !</span>
<span class="w">    </span><span class="c">!--------------------------------------------------------------------------!</span>
<span class="w">    </span><span class="k">FUNCTION </span><span class="n">BISECTION_METHOD</span><span class="p">(</span><span class="n">FUNC</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span>

<span class="w">        </span><span class="k">IMPLICIT NONE</span>

<span class="w">        </span><span class="c">! FUNC is a function f: [A, B] -&gt; Reals. Define this.</span>
<span class="w">        </span><span class="k">INTERFACE</span>
<span class="k">            FUNCTION </span><span class="n">FUNC</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="w">                </span><span class="k">IMPLICIT NONE</span>
<span class="k">                </span><span class="kt">REAL</span><span class="p">,</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">X</span>
<span class="w">                </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">FUNC</span>
<span class="w">            </span><span class="k">END FUNCTION </span><span class="n">FUNC</span>
<span class="w">        </span><span class="k">END INTERFACE</span>

<span class="w">        </span><span class="c">! The inputs are positive real numbers.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="p">,</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>

<span class="w">        </span><span class="c">! The output is also a positive real number, the root of FUNC.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">BISECTION_METHOD</span>

<span class="w">        </span><span class="c">! Dummy variable for keeping track of how many iterations we&#39;ve done.</span>
<span class="w">        </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ITERS</span>

<span class="w">        </span><span class="c">! The midpoint of the interval. The bisection method iteratively cuts</span>
<span class="w">        </span><span class="c">! the interval in half to find the root.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">MIDPOINT</span>

<span class="w">        </span><span class="c">! The endpoints of the current interval. These are updated with each</span>
<span class="w">        </span><span class="c">! iteration. We initially define LEFT so that FUNC(LEFT) &lt; 0, and</span>
<span class="w">        </span><span class="c">! similarly choose RIGHT to make 0 &lt; FUNC(RIGHT).</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">LEFT</span><span class="p">,</span><span class="w"> </span><span class="n">RIGHT</span>

<span class="w">        </span><span class="c">! The evaluations of A and B are used to determine LEFT and RIGHT.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">A_EVAL</span><span class="p">,</span><span class="w"> </span><span class="n">B_EVAL</span>

<span class="w">        </span><span class="c">! At each iteration we compute FUNC(MIDPOINT) and reset the interval</span>
<span class="w">        </span><span class="c">! depending on whether or not the value is positive.</span>
<span class="w">        </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">EVAL</span>

<span class="w">        </span><span class="c">! Initial setup, find out which evaluation is positive and which is</span>
<span class="w">        </span><span class="c">! negative. If the signs of the two agree we treat this as an error.</span>
<span class="w">        </span><span class="n">A_EVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">        </span><span class="n">B_EVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

<span class="w">        </span><span class="c">! Special case, A is a root. Set the output to A and return.</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">A_EVAL</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="n">LE</span><span class="p">.</span><span class="w"> </span><span class="nb">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">            </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>
<span class="w">            </span><span class="k">RETURN</span>
<span class="k">        END IF</span>

<span class="w">        </span><span class="c">! Similarly for B, if FUNC(B) ~= 0, return B.</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">B_EVAL</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="n">LE</span><span class="p">.</span><span class="w"> </span><span class="nb">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">            </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span>
<span class="w">            </span><span class="k">RETURN</span>
<span class="k">        END IF</span>

<span class="w">        </span><span class="c">! If FUNC(A) &lt; 0 &lt; FUNC(B), then LEFT = A and RIGHT = B.</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">LT</span><span class="p">.</span><span class="w"> </span><span class="n">B_EVAL</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>

<span class="w">            </span><span class="c">! If FUNC(A) and FUNC(B) have the same sign (both positive or</span>
<span class="w">            </span><span class="c">! both negative), return NaN. Bisection is undefined.</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="p">((</span><span class="n">A_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">GT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="nb">OR</span><span class="p">.</span><span class="w"> </span><span class="p">(</span><span class="n">B_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">LT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">                </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span>
<span class="w">                </span><span class="k">RETURN</span>
<span class="k">            END IF</span>

<span class="k">            </span><span class="n">LEFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>
<span class="w">            </span><span class="n">RIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span>

<span class="w">        </span><span class="c">! If FUNC(B) &lt; 0 &lt; FUNC(A), then LEFT = B and RIGHT = A.</span>
<span class="w">        </span><span class="k">ELSE</span>

<span class="w">            </span><span class="c">! Same sanity check as before, make sure the signs are different.</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="p">((</span><span class="n">A_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">LT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="nb">OR</span><span class="p">.</span><span class="w"> </span><span class="p">(</span><span class="n">B_EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">GT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">                </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">A</span><span class="p">)</span>
<span class="w">                </span><span class="k">RETURN</span>
<span class="k">            END IF</span>

<span class="k">            </span><span class="n">LEFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span>
<span class="w">            </span><span class="n">RIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>
<span class="w">        </span><span class="k">END IF</span>

<span class="k">        </span><span class="n">MIDPOINT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">)</span>

<span class="w">        </span><span class="c">! Iteratively perform the bisection method.</span>
<span class="w">        </span><span class="k">DO </span><span class="n">ITERS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">MAXIMUM_NUMBER_OF_ITERATIONS</span>

<span class="w">            </span><span class="c">! The interval is cut in half based on the sign of FUNC(MIDPOINT).</span>
<span class="w">            </span><span class="c">! Compute this and compare.</span>
<span class="w">            </span><span class="n">EVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">MIDPOINT</span><span class="p">)</span>

<span class="w">            </span><span class="c">! If MIDPOINT is close to a root we can exit the function.</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="nb">ABS</span><span class="p">(</span><span class="n">EVAL</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="n">LE</span><span class="p">.</span><span class="w"> </span><span class="nb">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">                </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIDPOINT</span>
<span class="w">                </span><span class="k">RETURN</span>
<span class="k">            END IF</span>

<span class="w">            </span><span class="c">! Otherwise, divide the range in half. If EVAL is negative we</span>
<span class="w">            </span><span class="c">! replace LEFT with MIDPOINT and move MIDPOINT closer to RIGHT.</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="n">EVAL</span><span class="w"> </span><span class="p">.</span><span class="n">LT</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">THEN</span>
<span class="k">                </span><span class="n">LEFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIDPOINT</span>
<span class="w">                </span><span class="n">MIDPOINT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">MIDPOINT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">RIGHT</span><span class="p">)</span>

<span class="w">            </span><span class="c">! Likewise, if EVAL is positive, replace RIGHT with MIDPOINT and</span>
<span class="w">            </span><span class="c">! move MIDPOINT closer to LEFT.</span>
<span class="w">            </span><span class="k">ELSE</span>
<span class="k">                </span><span class="n">RIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIDPOINT</span>
<span class="w">                </span><span class="n">MIDPOINT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">LEFT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">MIDPOINT</span><span class="p">)</span>
<span class="w">            </span><span class="k">END IF</span>
<span class="k">        END DO</span>

<span class="w">        </span><span class="c">! Provided |B - A| is not too big, we should now have a very good</span>
<span class="w">        </span><span class="c">! approximation to the root.</span>
<span class="w">        </span><span class="n">BISECTION_METHOD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIDPOINT</span>
<span class="w">    </span><span class="k">END FUNCTION </span><span class="n">BISECTION_METHOD</span>
<span class="k">END MODULE </span><span class="n">BISECTION</span>

<span class="c">! Program for testing our implementation of the bisection method.</span>
<span class="k">PROGRAM </span><span class="n">MAIN</span>

<span class="w">    </span><span class="k">USE </span><span class="n">BISECTION</span>
<span class="w">    </span><span class="k">IMPLICIT NONE</span>

<span class="w">    </span><span class="c">! We will compute pi by finding a root to sine on the interval [3, 4].</span>
<span class="w">    </span><span class="c">! The sine function is an intrinsic provided by Fortran.</span>
<span class="w">    </span><span class="k">INTRINSIC </span><span class="nb">SIN</span>

<span class="w">    </span><span class="c">! Pi is somewhere between 3 and 4, use this interval.</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span>

<span class="w">    </span><span class="c">! Variable for the output.</span>
<span class="w">    </span><span class="kt">REAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">PI</span>

<span class="w">    </span><span class="c">! Run the routine, compute pi, and print the result.</span>
<span class="w">    </span><span class="n">PI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BISECTION_METHOD</span><span class="p">(</span><span class="nb">SIN</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span>
<span class="w">    </span><span class="k">PRINT</span><span class="w"> </span><span class="s2">&quot;(A,F18.16)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;pi = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PI</span>

<span class="k">END PROGRAM </span><span class="n">MAIN</span>
</pre></div>

<h2 id="d">D<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using bisection.                    *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/09                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  Create an alias for real-valued functions f: R -&gt; R.                      */</span>
<span class="k">alias</span><span class="w"> </span><span class="n">realfunc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="k">pure</span><span class="w"> </span><span class="k">nothrow</span><span class="w"> </span><span class="nd">@nogc</span><span class="w"> </span><span class="nd">@safe</span><span class="p">;</span>

<span class="cm">/*  Computes the root of a function using the bisection method.               */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">bisection_method</span><span class="p">(</span><span class="n">realfunc</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  Floating-point absolute value (fabs) provided here.                   */</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">math</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">fabs</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">64U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Getting exact roots is hard using floating-point numbers. Allow a     *</span>
<span class="cm">     *  tolerance in our computation. This value is double precision epsilon. */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Variable for keeping track of how many iterations we have performed.  */</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  The midpoint for the bisection method. This will update as we iterate.*/</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  We do not require a &lt; b, nor do we require f(a) &lt; f(b). We only need  *</span>
<span class="cm">     *  one of these to evaluate to a negative under f and one to evaluate to *</span>
<span class="cm">     *  positive. We will call the negative entry left and positive one right.*/</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Evaluate f at the two endpoints to determine which is positive and    *</span>
<span class="cm">     *  which is negative. We transform [a, b] to [left, right] by doing this.*/</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.                   */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_eval</span><span class="w"> </span><span class="p">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Similarly, if f(b) = b, then we have already found the root. Return b.*/</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b_eval</span><span class="w"> </span><span class="p">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Compare the two evaluations and set left and right accordingly.       */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_eval</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="n">b_eval</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  If both evaluations are negative, or if both are positive, then   *</span>
<span class="cm">         *  the bisection method will not work. Return NaN.                   */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b_eval</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="p">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="p">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.         */</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  In this case the function starts positive and tends to a negative.    */</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be         *</span>
<span class="cm">         *  negative and one to be positive. Abort if both have the same sign.*/</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_eval</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="p">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="p">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                    */</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.          */</span>
<span class="w">    </span><span class="n">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*  Iteratively divide the range in half to find the root.                */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="p">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  If f(x) is very small, we are close to a root and can break out   *</span>
<span class="cm">         *  of this for loop. Check for this.                                 */</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*  Apply bisection to get a better approximation for the root. We    *</span>
<span class="cm">         *  have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the      *</span>
<span class="cm">         *  interval [left, right] with [midpoint, right]. Set left to the    *</span>
<span class="cm">         *  midpoint and reset the midpoint to be closer to right.            */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  In the other case, f(midpoint) &gt; 0, we replace right with the     *</span>
<span class="cm">         *  midpoint, changing [left, right] into [left, midpoint]. We then   *</span>
<span class="cm">         *  set the midpoint to be closer to left.                            */</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  After n iterations, we are no more than |b - a| / 2^n away from the   *</span>
<span class="cm">     *  root of the function. 1 / 2^n goes to zero very quickly, meaning the  *</span>
<span class="cm">     *  convergence is very quick.                                            */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*  End of bisection_method.                                                  */</span>

<span class="cm">/*  Main routine used for testing our implementation of the bisection method. */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  stdio contains &quot;printf&quot;, used for printing text.                      */</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">printf</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  We will compute pi via bisection of sine on the interval [3, 4].      */</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">math</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">sin</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.            */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate   *</span>
<span class="cm">     *  to about 16 decimals.                                                 */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bisection_method</span><span class="p">(&amp;</span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;pi = %.16f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h2 id="swift">Swift<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using bisection.                    *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/04/17                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  fabs (floating-point absolute value) found here.                          */</span>
<span class="kd">import</span> <span class="nc">Foundation</span>

<span class="cm">/*  Function pointer notation is a little confusing. Create a typedef for it  *</span>
<span class="cm"> *  so we do not need to explicitly use it later.                             */</span>
<span class="kd">typealias</span> <span class="n">RealFunc</span> <span class="p">=</span> <span class="p">(</span><span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Double</span>

<span class="cm">/*  Computes the root of a function using the bisection method.               */</span>
<span class="kd">func</span> <span class="nf">bisectionMethod</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">RealFunc</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Double</span> <span class="p">{</span>

    <span class="cm">/*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 */</span>
    <span class="kd">let</span> <span class="nv">maximum_number_of_iterations</span><span class="p">:</span> <span class="nb">UInt32</span> <span class="p">=</span> <span class="mi">64</span>

    <span class="cm">/*  Getting exact roots is hard using floating-point numbers. Allow a     *</span>
<span class="cm">     *  tolerance in our computation. This value is double precision epsilon. */</span>
    <span class="kd">let</span> <span class="nv">epsilon</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">2.220446049250313E-16</span>

    <span class="cm">/*  The midpoint for the bisection method. This will update as we iterate.*/</span>
    <span class="kd">var</span> <span class="nv">midpoint</span><span class="p">:</span> <span class="nb">Double</span>

    <span class="cm">/*  We do not require a &lt; b, nor do we require f(a) &lt; f(b). We only need  *</span>
<span class="cm">     *  one of these to evaluate to a negative under f and one to evaluate to *</span>
<span class="cm">     *  positive. We will call the negative entry left and positive one right.*/</span>
    <span class="kd">var</span> <span class="nv">left</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">var</span> <span class="nv">right</span><span class="p">:</span> <span class="nb">Double</span>

    <span class="cm">/*  Evaluate f at the two endpoints to determine which is positive and    *</span>
<span class="cm">     *  which is negative. We transform [a, b] to [left, right] by doing this.*/</span>
    <span class="kd">let</span> <span class="nv">a_eval</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">b_eval</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.                   */</span>
    <span class="k">if</span> <span class="n">a_eval</span> <span class="p">==</span> <span class="mf">0.0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="p">}</span>

    <span class="cm">/*  Similarly, if f(b) = 0, then we have already found the root. Return b.*/</span>
    <span class="k">if</span> <span class="n">b_eval</span> <span class="p">==</span> <span class="mf">0.0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="p">}</span>

    <span class="cm">/*  Compare the two evaluations and set left and right accordingly.       */</span>
    <span class="k">if</span> <span class="n">a_eval</span> <span class="o">&lt;</span> <span class="n">b_eval</span> <span class="p">{</span>

        <span class="cm">/*  If both evaluations are negative, or if both are positive, then   *</span>
<span class="cm">         *  the bisection method will not work. Return NaN.                   */</span>
        <span class="k">if</span> <span class="n">b_eval</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">||</span> <span class="n">a_eval</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.         */</span>
        <span class="kr">left</span> <span class="p">=</span> <span class="n">a</span>
        <span class="kr">right</span> <span class="p">=</span> <span class="n">b</span>

    <span class="cm">/*  In this case the function starts positive and tends to a negative.    */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/*  Same sanity check as before. We need one evaluation to be         *</span>
<span class="cm">         *  negative and one to be positive. Abort if both have the same sign.*/</span>
        <span class="k">if</span> <span class="n">a_eval</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">||</span> <span class="n">b_eval</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                    */</span>
        <span class="kr">left</span> <span class="p">=</span> <span class="n">b</span>
        <span class="kr">right</span> <span class="p">=</span> <span class="n">a</span>
    <span class="p">}</span>

    <span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.          */</span>
    <span class="n">midpoint</span> <span class="p">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

    <span class="cm">/*  Iteratively divide the range in half to find the root.                */</span>
    <span class="k">for</span> <span class="kc">_</span> <span class="k">in</span> <span class="mi">0</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">maximum_number_of_iterations</span> <span class="p">{</span>

        <span class="cm">/*  If f(x) is very small, we are close to a root and can break out   *</span>
<span class="cm">         *  of this for loop. Check for this.                                 */</span>
        <span class="kd">let</span> <span class="nv">eval</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">abs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">epsilon</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>

        <span class="cm">/*  Apply bisection to get a better approximation for the root. We    *</span>
<span class="cm">         *  have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the      *</span>
<span class="cm">         *  interval [left, right] with [midpoint, right]. Set left to the    *</span>
<span class="cm">         *  midpoint and reset the midpoint to be closer to right.            */</span>
        <span class="k">if</span> <span class="n">eval</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="p">{</span>
            <span class="kr">left</span> <span class="p">=</span> <span class="n">midpoint</span>
            <span class="n">midpoint</span> <span class="p">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">midpoint</span> <span class="o">+</span> <span class="kr">right</span><span class="p">)</span>

        <span class="cm">/*  In the other case, f(midpoint) &gt; 0, we replace right with the     *</span>
<span class="cm">         *  midpoint, changing [left, right] into [left, midpoint]. We then   *</span>
<span class="cm">         *  set the midpoint to be closer to left.                            */</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kr">right</span> <span class="p">=</span> <span class="n">midpoint</span>
            <span class="n">midpoint</span> <span class="p">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="kr">left</span> <span class="o">+</span> <span class="n">midpoint</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/*  After n iterations, we are no more than |b - a| / 2^n away from the   *</span>
<span class="cm">     *  root of the function. 1 / 2^n goes to zero very quickly, meaning the  *</span>
<span class="cm">     *  convergence is very quick.                                            */</span>
    <span class="k">return</span> <span class="n">midpoint</span>
<span class="p">}</span>
<span class="cm">/*  End of bisection_method.                                                  */</span>

<span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.                */</span>
<span class="kd">let</span> <span class="nv">a</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">3.0</span>
<span class="kd">let</span> <span class="nv">b</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">4.0</span>

<span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate       *</span>
<span class="cm"> *  to about 16 decimals.                                                     */</span>
<span class="kd">let</span> <span class="nv">pi</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="n">bisectionMethod</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">sin</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;pi = </span><span class="si">\(</span><span class="n">pi</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>

<h2 id="c3">C3<br /></h2>

<h2 id="cpp">Cpp<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using the bisection method.         *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/03/09                                                        *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*  stdio provides the &quot;printf&quot; function, used for printing text.             */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>

<span class="cm">/*  Floating-point absolute value function, fabs, provided here.              */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>

<span class="cm">/*  Function pointer notation is a little confusing. Create a typedef for it  *</span>
<span class="cm"> *  so we do not need to explicitly use it later.                             */</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>

<span class="cm">/*  Class providing an implementation of the bisection method.                */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Bisection</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  The error after n iterations is |b - a| / 2^n. Since double has a     *</span>
<span class="cm">     *  52-bit mantissa, if |b - a| ~= 1, then after 52 steps we can halt the *</span>
<span class="cm">     *  program. To allow for |b - a| to be larger, we stop the process after *</span>
<span class="cm">     *  at most 64 iterations.                                                */</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64U</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  We want the function visible outside the class. Declare it public.    */</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>

<span class="w">        </span><span class="cm">/*  Computes the root of a function using the bisection method.       */</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">root</span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/*  The maximum allowed error. This is double precision epsilon.  */</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">epsilon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.220446049250313E-16</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Variable for keeping track of the number of iterations.       */</span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iters</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  The midpoint for the bisection. This updates as we iterate.   */</span>
<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  We do not require a &lt; b, nor f(a) &lt; f(b). We need one of      *</span>
<span class="cm">             *  these to evaluate negative under f and one to evaluate to     *</span>
<span class="cm">             *  positive. Call the negative entry left and positive one right.*/</span>
<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Evaluate f at the endpoints to determine which is positive    *</span>
<span class="cm">             *  and which is negative, transforming [a, b] to [left, right].  */</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.           */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Similarly, if f(b) = 0, then we found the root. Return b.     */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b_eval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">            </span><span class="cm">/*  Compare the two evaluations and set the left and right values.*/</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b_eval</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/*  If both evaluations are negative, or if both are positive,*</span>
<span class="cm">                 *  then the bisection method will not work. Return NaN.      */</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">a_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">                </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b. */</span>
<span class="w">                </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">                </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/*  In this case the function starts positive and goes negative.  */</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be *</span>
<span class="cm">                 *  negative and one to be positive. Abort if the signs agree.*/</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a_eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b_eval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">                </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.            */</span>
<span class="w">                </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">                </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.  */</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*  Iteratively divide the range in half to find the root.        */</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iters</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/*  If f(x) is very small, we are close to a root and can     *</span>
<span class="cm">                 *  break out of this for loop. Check for this.               */</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">);</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/*  Apply bisection to get a better approximation. We have    *</span>
<span class="cm">                 *  f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the   *</span>
<span class="cm">                 *  interval [left, right] with [midpoint, right]. Set left   *</span>
<span class="cm">                 *  to the midpoint and set midpoint to be closer to right.   */</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">                    </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="cm">/*  If f(midpoint) &gt; 0, then replace right with the midpoint, *</span>
<span class="cm">                 *  changing [left, right] into [left, midpoint]. We then set *</span>
<span class="cm">                 *  the midpoint to be closer to left.                        */</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">                    </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/*  After n iterations, we are at most |b - a| / 2^n from the     *</span>
<span class="cm">             *  root of the function. 1 / 2^n goes to zero very quickly,      *</span>
<span class="cm">             *  meaning the convergence is very quick.                        */</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cm">/*  End of root.                                                      */</span>
<span class="p">};</span>
<span class="cm">/*  End of Bisection definition.                                              */</span>

<span class="cm">/*  Main routine used for testing our implementation of the Bisection method. */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.            */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate   *</span>
<span class="cm">     *  to about 16 decimals.                                                 */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bisection</span><span class="o">::</span><span class="n">root</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;pi = %.16f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h2 id="kt">Kt<br /></h2>
<div class="highlight"><pre><span></span><span class="cm">/******************************************************************************</span>
<span class="cm"> *                                  LICENSE                                   *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  This file is part of mitx_mathematics_programming_examples.               *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is free software: you can           *</span>
<span class="cm"> *  redistribute it and/or modify it under the terms of the GNU General       *</span>
<span class="cm"> *  Public License as published by the Free Software Foundation, either       *</span>
<span class="cm"> *  version 3 of the License, or (at your option) any later version.          *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  mitx_mathematics_programming_examples is distributed in the hope that     *</span>
<span class="cm"> *  it will be useful but WITHOUT ANY WARRANTY; without even the implied      *</span>
<span class="cm"> *  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.          *</span>
<span class="cm"> *  See the GNU General Public License for more details.                      *</span>
<span class="cm"> *                                                                            *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License         *</span>
<span class="cm"> *  along with mitx_mathematics_programming_examples. If not, see             *</span>
<span class="cm"> *  &lt;https://www.gnu.org/licenses/&gt;.                                          *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Purpose:                                                                  *</span>
<span class="cm"> *      Calculates the root of a function using bisection.                    *</span>
<span class="cm"> ******************************************************************************</span>
<span class="cm"> *  Author: Ryan Maguire                                                      *</span>
<span class="cm"> *  Date:   2025/05/18                                                        *</span>
<span class="cm"> ******************************************************************************/</span>
<span class="k">import</span><span class="w"> </span><span class="nn">kotlin.math.abs</span>
<span class="k">import</span><span class="w"> </span><span class="nn">kotlin.math.sin</span>

<span class="cm">/*  Function pointer notation is a little confusing. Create a typedef for it  *</span>
<span class="cm"> *  so we do not need to explicitly use it later.                             */</span>
<span class="k">typealias</span><span class="w"> </span><span class="n">RealFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Double</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">Double</span>

<span class="cm">/*  Computes the root of a function using the bisection method.               */</span>
<span class="kd">fun</span><span class="w"> </span><span class="nf">bisectionMethod</span><span class="p">(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="n">RealFunc</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="p">):</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  Tell the algorithm to stop after several iterations to avoid an       *</span>
<span class="cm">     *  infinite loop. Double precision numbers have 52 bits in the mantissa, *</span>
<span class="cm">     *  so if |b - a| ~= 1, after 52 iterations of bisection we will get as   *</span>
<span class="cm">     *  close as we can to the root. To allow for |b - a| to be larger, halt  *</span>
<span class="cm">     *  the algorithm after at most 64 steps.                                 */</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">maximum_number_of_iterations</span><span class="p">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">64</span>

<span class="w">    </span><span class="cm">/*  Getting exact roots is hard using floating-point numbers. Allow a     *</span>
<span class="cm">     *  tolerance in our computation. This value is double precision epsilon. */</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">epsilon</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2.220446049250313E-16</span>

<span class="w">    </span><span class="cm">/*  The midpoint for the bisection method. This will update as we iterate.*/</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nv">midpoint</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span>

<span class="w">    </span><span class="cm">/*  We do not require a &lt; b, nor do we require f(a) &lt; f(b). We only need  *</span>
<span class="cm">     *  one of these to evaluate to a negative under f and one to evaluate to *</span>
<span class="cm">     *  positive. We will call the negative entry left and positive one right.*/</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nv">left</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nv">right</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span>

<span class="w">    </span><span class="cm">/*  Evaluate f at the two endpoints to determine which is positive and    *</span>
<span class="cm">     *  which is negative. We transform [a, b] to [left, right] by doing this.*/</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">aEval</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">bEval</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="w">    </span><span class="cm">/*  Rare case, f(a) = 0. Return a, no bisection needed.                   */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Similarly, if f(b) = 0, then we have already found the root. Return b.*/</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bEval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Compare the two evaluations and set left and right accordingly.       */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bEval</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If both evaluations are negative, or if both are positive, then   *</span>
<span class="cm">         *  the bisection method will not work. Return NaN.                   */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">bEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">aEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0.0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Otherwise, since f(a) &lt; f(b), set left = a and right = b.         */</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span>

<span class="w">    </span><span class="cm">/*  In this case the function starts positive and tends to a negative.    */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*  Same sanity check as before. We need one evaluation to be         *</span>
<span class="cm">         *  negative and one to be positive. Abort if both have the same sign.*/</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">aEval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">bEval</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0.0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Since f(a) &gt; f(b), set left = b and right = a.                    */</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  Start the bisection method. Compute the midpoint of a and b.          */</span>
<span class="w">    </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>

<span class="w">    </span><span class="cm">/*  Iteratively divide the range in half to find the root.                */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iters</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">..</span><span class="w"> </span><span class="n">maximum_number_of_iterations</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*  If f(x) is very small, we are close to a root and can break out   *</span>
<span class="cm">         *  of this for loop. Check for this.                                 */</span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="nv">eval</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">eval</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">epsilon</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*  Apply bisection to get a better approximation for the root. We    *</span>
<span class="cm">         *  have f(left) &lt; 0 &lt; f(right). If f(midpoint) &lt; 0, replace the      *</span>
<span class="cm">         *  interval [left, right] with [midpoint, right]. Set left to the    *</span>
<span class="cm">         *  midpoint and reset the midpoint to be closer to right.            */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">midpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">)</span>

<span class="w">        </span><span class="cm">/*  In the other case, f(midpoint) &gt; 0, we replace right with the     *</span>
<span class="cm">         *  midpoint, changing [left, right] into [left, midpoint]. We then   *</span>
<span class="cm">         *  set the midpoint to be closer to left.                            */</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">midpoint</span>
<span class="w">            </span><span class="n">midpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">midpoint</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*  After n iterations, we are no more than |b - a| / 2^n away from the   *</span>
<span class="cm">     *  root of the function. 1 / 2^n goes to zero very quickly, meaning the  *</span>
<span class="cm">     *  convergence is very quick.                                            */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">midpoint</span>
<span class="p">}</span>
<span class="cm">/*  End of bisection_method.                                                  */</span>

<span class="cm">/*  Test out our function, compute the square root of 2.                      */</span>
<span class="kd">fun</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*  pi is somewhere between 3 and 4, and it is a root to sine.            */</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">a</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3.0</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">b</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4.0</span>

<span class="w">    </span><span class="cm">/*  Compute pi using bisection. We should get pi = 3.14159..., accurate   *</span>
<span class="cm">     *  to about 16 decimals.                                                 */</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nv">pi</span><span class="p">:</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bisectionMethod</span><span class="p">(</span><span class="o">::</span><span class="n">sin</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;pi = </span><span class="si">$</span><span class="n">pi</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ryan Maguire</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ryan Maguire</li><li><a class="u-email" href="mailto:rmaguire@protonmail.com">rmaguire@protonmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ryanmaguire"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ryanmaguire</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Mathematics, Physics, and Programming</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
